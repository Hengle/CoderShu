[{"title":"Unity动画文件优化探究","date":"2017-06-14T12:20:00.000Z","path":"2017/06/14/UnityOptimizeAnimationClip/","text":"主要思路 压缩浮点数精度 去除scale曲线 各Size含义在参考了王亮的代码后，我也尝试优化了动画文件，发现一个\b很奇怪的现象。下图中Inspector中显示的大小并没有任何变化，但是文件大小和Profiler中的内存大小确实是减小了。那么Inspector中显示的Size是什么含义呢？下图中的动画文件不包含Scale曲线，所以这次优化中只压缩了浮点数精度。我分别对比了动画文件优化前和优化后的大小 FileSize FileInfo.Length取得的文件大小 可以在操作系统的文件系统中\b看到 MemorySize Profiler.GetRuntimeMemorySize取得的内存大小 可以在Profiler中通过采样看到 BlobSize 反射取得的AnimationClipStats.size二进制大小 显示在AnimationClip的Inspector的面板上 前后 FileSize Editor MemorySize 真机MemorySize BlobSize 优化前 11.75kb 8.75kb 3.1kb 2.8kb 优化后 5.87kb 3.63kb 3.1kb 2.8kb 对比 -50% -58% -0% -0% \b红色框内即是BlobSize，在我的理解，FileSize是指文件在硬盘中占的大小，BlobSize是从\b文件反序列化出来的对象的二进制大小。Editor下的MemorySize不仅有序列化后的内存大小，还维护了一份原文件的内存。就像我们在Editor下加载一张Texture内存是双份一样，而真机下就约等于BlobSize。真机下的MemorySize和Inspector里的BlobSize非常接近，BlobSize可以认为是真机上的内存大小，这个大小更有参考意义。 下面这次测试证实了我的想法，下图这个动画文件原来Inspector中Scale的值为4，即有Scale曲线。所以BlobSize减小了27%。 前后 FileSize Editor MemorySize 真机MemorySize BlobSize 优化前 85.43kb 46.29kb 10.2kb 优化后 23.34kb 18.69kb 7.4kb 对比 -73% -60 -27% Curve减少导致内存减小从上面的实验可以看出来，只动画文件的压缩精度，没有引起Curve减少。\bBlobSize是不会有任何变化的，因为每个浮点数固定占32bit。而文件大小、AB大小、Editor下的内存大小，压缩精度后不管有没有引起Curve的变化，都会变小。裁剪动画文件的精度，意味着点的位置发生了变化，所以Constant Curve和Dense Curve的数量也有可能发生变化。由于是裁剪精度所以动画的点更稀疏了，而连续相同的点更多了。所以Dense Curve是减少了，Constant Curve是增多了，总的内存是减小了。 Constant Curve只需要最左边的点就可以描述一个曲线段 总结隔壁项目组对他们项目中所有的动画文件都进行了优化。其中文件大小从820m-&gt;225, ab大小从72m-&gt;64m, 内存大小从50m-&gt;40m。总的来说动画文件的scale越多优化越明显。 取BlobSize代码AnimationClip aniClip = AssetDatabase.LoadAssetAtPath&lt;AnimationClip&gt; (path); var fileInfo = new System.IO.FileInfo(path); Debug.Log(fileInfo.Length);//FileSize Debug.Log(Profiler.GetRuntimeMemorySize (aniClip));//MemorySize Assembly asm = Assembly.GetAssembly(typeof(Editor)); MethodInfo getAnimationClipStats = typeof(AnimationUtility).GetMethod(\"GetAnimationClipStats\", BindingFlags.Static | BindingFlags.NonPublic); Type aniclipstats = asm.GetType(\"UnityEditor.AnimationClipStats\"); FieldInfo sizeInfo = aniclipstats.GetField (\"size\", BindingFlags.Public | BindingFlags.Instance); var stats = getAnimationClipStats.Invoke(null, new object[]{aniClip}); Debug.Log(EditorUtility.FormatBytes((int)sizeInfo.GetValue(stats)));//BlobSize 工具代码最后附上工具的代码和简要使用说明，选中想要优化的文件夹或文件，右键Animation-&gt;裁剪浮点数去除Scale。 /* Author: suijiabin */ using System; using System.Collections.Generic; using UnityEngine; using System.Reflection; using UnityEditor; using System.IO; namespace EditorTool { class AnimationOpt { static Dictionary&lt;uint,string&gt; _FLOAT_FORMAT; static MethodInfo getAnimationClipStats; static FieldInfo sizeInfo; static object[] _param = new object[1]; static AnimationOpt () { _FLOAT_FORMAT = new Dictionary&lt;uint, string&gt; (); for (uint i = 1; i &lt; 6; i++) { _FLOAT_FORMAT.Add (i, \"f\" + i.ToString ()); } Assembly asm = Assembly.GetAssembly (typeof(Editor)); getAnimationClipStats = typeof(AnimationUtility).GetMethod (\"GetAnimationClipStats\", BindingFlags.Static | BindingFlags.NonPublic); Type aniclipstats = asm.GetType (\"UnityEditor.AnimationClipStats\"); sizeInfo = aniclipstats.GetField (\"size\", BindingFlags.Public | BindingFlags.Instance); } AnimationClip _clip; string _path; public string path { get{ return _path;} } public long originFileSize { get; private set; } public int originMemorySize { get; private set; } public int originInspectorSize { get; private set; } public long optFileSize { get; private set; } public int optMemorySize { get; private set; } public int optInspectorSize { get; private set; } public AnimationOpt (string path, AnimationClip clip) { _path = path; _clip = clip; _GetOriginSize (); } void _GetOriginSize () { originFileSize = _GetFileZie (); originMemorySize = _GetMemSize (); originInspectorSize = _GetInspectorSize (); } void _GetOptSize () { optFileSize = _GetFileZie (); optMemorySize = _GetMemSize (); optInspectorSize = _GetInspectorSize (); } long _GetFileZie () { FileInfo fi = new FileInfo (_path); return fi.Length; } int _GetMemSize () { return Profiler.GetRuntimeMemorySize (_clip); } int _GetInspectorSize () { _param [0] = _clip; var stats = getAnimationClipStats.Invoke (null, _param); return (int)sizeInfo.GetValue (stats); } void _OptmizeAnimationScaleCurve () { if (_clip != null) { //去除scale曲线 foreach (EditorCurveBinding theCurveBinding in AnimationUtility.GetCurveBindings(_clip)) { string name = theCurveBinding.propertyName.ToLower (); if (name.Contains (\"scale\")) { AnimationUtility.SetEditorCurve (_clip, theCurveBinding, null); Debug.LogFormat (\"关闭{0}的scale curve\", _clip.name); } } } } void _OptmizeAnimationFloat_X (uint x) { if (_clip != null &amp;&amp; x &gt; 0) { //浮点数精度压缩到f3 AnimationClipCurveData[] curves = null; curves = AnimationUtility.GetAllCurves (_clip); Keyframe key; Keyframe[] keyFrames; string floatFormat; if (_FLOAT_FORMAT.TryGetValue (x, out floatFormat)) { if (curves != null &amp;&amp; curves.Length &gt; 0) { for (int ii = 0; ii &lt; curves.Length; ++ii) { AnimationClipCurveData curveDate = curves [ii]; if (curveDate.curve == null || curveDate.curve.keys == null) { //Debug.LogWarning(string.Format(\"AnimationClipCurveData {0} don't have curve; Animation name {1} \", curveDate, animationPath)); continue; } keyFrames = curveDate.curve.keys; for (int i = 0; i &lt; keyFrames.Length; i++) { key = keyFrames [i]; key.value = float.Parse (key.value.ToString (floatFormat)); key.inTangent = float.Parse (key.inTangent.ToString (floatFormat)); key.outTangent = float.Parse (key.outTangent.ToString (floatFormat)); keyFrames [i] = key; } curveDate.curve.keys = keyFrames; _clip.SetCurve (curveDate.path, curveDate.type, curveDate.propertyName, curveDate.curve); } } } else { Debug.LogErrorFormat (\"目前不支持{0}位浮点\", x); } } } public void Optimize (bool scaleOpt, uint floatSize) { if (scaleOpt) { _OptmizeAnimationScaleCurve (); } _OptmizeAnimationFloat_X (floatSize); _GetOptSize (); } public void Optimize_Scale_Float3 () { Optimize (true, 3); } public void LogOrigin () { _logSize (originFileSize, originMemorySize, originInspectorSize); } public void LogOpt () { _logSize (optFileSize, optMemorySize, optInspectorSize); } public void LogDelta () { } void _logSize (long fileSize, int memSize, int inspectorSize) { Debug.LogFormat (\"{0} \\nSize=[ {1} ]\", _path, string.Format (\"FSize={0} ; Mem-&gt;{1} ; inspector-&gt;{2}\", EditorUtility.FormatBytes (fileSize), EditorUtility.FormatBytes (memSize), EditorUtility.FormatBytes (inspectorSize))); } } public class OptimizeAnimationClipTool { static List&lt;AnimationOpt&gt; _AnimOptList = new List&lt;AnimationOpt&gt; (); static List&lt;string&gt; _Errors = new List&lt;string&gt;(); static int _Index = 0; [MenuItem(\"Assets/Animation/裁剪浮点数去除Scale\")] public static void Optimize() { _AnimOptList = FindAnims (); if (_AnimOptList.Count &gt; 0) { _Index = 0; _Errors.Clear (); EditorApplication.update = ScanAnimationClip; } } private static void ScanAnimationClip() { AnimationOpt _AnimOpt = _AnimOptList[_Index]; bool isCancel = EditorUtility.DisplayCancelableProgressBar(\"优化AnimationClip\", _AnimOpt.path, (float)_Index / (float)_AnimOptList.Count); _AnimOpt.Optimize_Scale_Float3(); _Index++; if (isCancel || _Index &gt;= _AnimOptList.Count) { EditorUtility.ClearProgressBar(); Debug.Log(string.Format(\"--优化完成-- 错误数量: {0} 总数量: {1}/{2} 错误信息↓:\\n{3}\\n----------输出完毕----------\", _Errors.Count, _Index, _AnimOptList.Count, string.Join(string.Empty, _Errors.ToArray()))); Resources.UnloadUnusedAssets(); GC.Collect(); AssetDatabase.SaveAssets(); EditorApplication.update = null; _AnimOptList.Clear(); _cachedOpts.Clear (); _Index = 0; } } static Dictionary&lt;string,AnimationOpt&gt; _cachedOpts = new Dictionary&lt;string, AnimationOpt&gt; (); static AnimationOpt _GetNewAOpt (string path) { AnimationOpt opt = null; if (!_cachedOpts.ContainsKey(path)) { AnimationClip clip = AssetDatabase.LoadAssetAtPath&lt;AnimationClip&gt; (path); if (clip != null) { opt = new AnimationOpt (path, clip); _cachedOpts [path] = opt; } } return opt; } static List&lt;AnimationOpt&gt; FindAnims() { string[] guids = null; List&lt;string&gt; path = new List&lt;string&gt;(); List&lt;AnimationOpt&gt; assets = new List&lt;AnimationOpt&gt; (); UnityEngine.Object[] objs = Selection.GetFiltered(typeof(object), SelectionMode.Assets); if (objs.Length &gt; 0) { for(int i = 0; i &lt; objs.Length; i++) { if (objs [i].GetType () == typeof(AnimationClip)) { string p = AssetDatabase.GetAssetPath (objs [i]); AnimationOpt animopt = _GetNewAOpt (p); if (animopt != null) assets.Add (animopt); } else path.Add(AssetDatabase.GetAssetPath (objs [i])); } guids = AssetDatabase.FindAssets (string.Format (\"t:{0}\", typeof(AnimationClip).ToString().Replace(\"UnityEngine.\", \"\")), path.ToArray()); } else { guids = AssetDatabase.FindAssets (string.Format (\"t:{0}\", typeof(AnimationClip).ToString().Replace(\"UnityEngine.\", \"\"))); } for(int i = 0; i &lt; guids.Length; i++) { string assetPath = AssetDatabase.GUIDToAssetPath (guids [i]); AnimationOpt animopt = _GetNewAOpt (assetPath); if (animopt != null) assets.Add (animopt); } return assets; } } }","tags":[{"name":"Unity","slug":"Unity","permalink":"blog.codershu.com/tags/Unity/"}]},{"title":"Lua性能优化（一）：Lua内存优化","date":"2017-05-08T15:44:00.000Z","path":"2017/05/08/luaperformance/","text":"本文章仅供稿于知乎、UWA和我个人网页，未经允许禁止转载。 大家好，我是舒航，现任职于心动网络，主要负责RO的优化工作。今天主要想和大家分享一下，我这段时间在Lua性能优化方面的一些经验。现在市面上大部分Unity游戏都能支持热更，主要热更Lua和一些资源。而Lua主要实现一些UI界面之类的非核心逻辑，这样虽然Lua这部分代码非常灵活，增加功能、修复BUG都非常方便。但是由于Lua实现的大部分都是UI，那么lua热更出去的功能最多就是一些新UI界面罢了，或者用资源配合配置表来扩充下游戏既有内容。如果想做个特殊的玩法势必受到掣肘，一般最后都会发现导出的接口不全，非得打整包才行。为了使得RO的玩法更灵活，热更的游戏内容更丰富，其实就是为了满足策划们的各种需求啦，RO战斗逻辑的主体都是在Lua中完成。所以RO相对于其他的游戏，对Lua代码的性能要求会更高一些。在我对Lua代码进行性能优化的时候，主要分为两部分： 内存优化 常驻内存优化 内存分配优化 内存泄露优化 CPU优化 这篇文章主要是和大家分享第一点，在内存优化上的一些经验和手段。在我进行Lua优化之前，我们已经请过UWA团队进行过专业的诊断了，而且收效很好，在此给UWA团队赞一个。那么，面对一个已经进行过一次彻底优化的项目，要进行更深入的优化之前首先要问自己一个问题： 我为什么能比前人优化得更彻底，做到前人没有做到得事情呢？ 总的来说就是两点： 工具更先进 项目更熟悉 所以在这样的策略下，我主要是针对我们的项目编写了两个工具，LuaMemoryMonitor和LuaProfiler。一个用于优化内存泄露和内存分布，一个用于优化内存分配。有了更好的工具之后，再针对性地优化自己项目的代码，无论是效率还是结果都非常好。LuaMemoryMonitor能在十几分钟内就定位到泄露的代码，用这个工具我们一下午就查清了战斗中的内存泄露，并且能清晰地列出Lua的内存分布。而LuaProfiler帮助我们把Lua内存分配速度降低到了原来的40-50%。 LuaMemoryMonitorLuaMemoryMonitor主要由两部分组成： C库Snapshot UnityEditor 一、 C库的实现细节C库的主要工作有： 快照_G 计算Lua对象内存大小 储存快照 1. 快照_GLua中可回收的对象递归关系如图：遍历_G时按以下的结构进行遍历，只需要编写5个函数traverse_object、traverse_table、traverse_function、traverse_userdata、traverse_thread，然后从traverse_table(_G)开始递归即可。在统计内存大小时，即要统计对象本身占用的内存，也要递归地遍历它所引用的所有对象占用的内存。其中string是Lua内部管理的，统计时要注意同一字符串的不同引用不能重复统计内存。 有兴趣的详见Lua源码lgc.c propagatemark 函数 2. 计算Lua对象内存大小对Lua当前内存进行快照时，我主要是快照_G，如果有需要的话可以快照Registry。如果仅仅是查内存泄露，那么不统计_G内每一Entry的内存大小也可以。但是我为了分析内存分布，那么必须得统计每一Entry的内存大小。统计Lua对象的内存大小是没有现成的接口的，我这里给大家提供一种思路，也是Lua源码中统计对象内存大小的办法。例如一个Table占用的内存大小为： size = sizeof(Table) + sizeof(TValue) * h-&gt;sizearray + sizeof(Node) * (isdummy(h) ? 0 : sizenode(h)); //还要加上Table引用的所有GCObject size = size + sizeof(metatble) + sizeof(keys) + sizeof(values); 3. 储存快照由于要对Lua内存进行分析，那么就不能把快照又存到Lua内，这样很容易干扰自己的数据采集。这也是把快照的代码写在C里的一个重要原因，如果是在Lua里写的话，就必须要小心翼翼地处理这些数据了。而写在C里就很好解决了，我在C里用一颗多节点树来储存每一个快照，多个快照组成一个链表。 二、 UnityEditor1. Editor特性Snapshot库已经为编辑器准备好了所有数据了，现在只需要想一个好主意、好方法来利用这些数据。这里我做了一个特别的功能，可以很高效地利用这些数据。在UnityEditor里可以对每个快照进行逻辑操作。 求交集 即两个或多个快照中都存在的对象，即这些快照中的常驻内存。 求补集 A在B中的补集指在A中但不在B中的对象，即A相对于B的增量。 简单例子：在刚进入战斗时采样得到A快照，战斗一段时间后采样得到B快照，离开战斗场景回到主城，手动GC后采样得到C快照。求AB的补集得到一个新的快照D，D即是战斗期间新增的内存。求AC的补集得到快照E，E即是 战斗期间新增并且离开战斗GC后没有释放掉的内存 。对D和E求交集，得到快照F，F即是战斗中新增但是回到主城后释放掉的内存。这其中E中的对象非常有可能就是泄露了的内存，而F中的对象是可以尝试更早地释放的内存。这时可以选中E快照，把E快照输出到Editor上，输出为一个树状结构，就像Unity自带的Profiler中一样，如果有泄露的话基本上就无所遁形了。而直接输出A快照的话，就能得到刚进入战斗时的内存分布。 三、 常见泄漏：C#代理我们项目中查到的比较多的泄露就是C#代理了，如果把Lua匿名函数注册给C#的代理，那么这个Lua匿名函数将不能正确地被LuaGC了，也就是泄露了。改进方法就是不把Lua匿名函数注册给C#代理，这样的话，每隔一段时间C#都会主动Dispose。 四、 其他内存优化：常驻内存优化常驻内存方面我们一直控制的很好，这次我们主要是优化了大量的table配置表，这个优化主要参考了UWA中的这篇文章Lua配置表存储优化方案——卢建。 五、 LuaMemoryMonitor改进现在LuaMemoryMonitor定位是一个快速定位泄露的工具，还需要提前知道疑似泄露的地方，然后有针对地采样。有一个改进方法是，在Lua中写一个定期检查内存疑似泄露的工具，然后在疑似泄露的地方用LuaMemoryMonitor进行快速定位。 LuaProfiler解决了常驻内存和内存泄露的麻烦后，发现内存增长的很快，很短时间内就会到达我们项目设置的阈值，迎来一次GC。而刚GC完空余出来的内存又会迅速地被分配出去，内存长时间处于高位。频繁分配内存不仅降低了性能，还使手机更容易发热了。为了定位和优化内存的高分配，我模仿Unity的Profiler写了一个LuaProfiler，并做了相应的扩展。这个工具也由两部分组成： C库 UnityEditor 一、 LuaProfiler的C库LuaProfiler的C库主要完成了数据采集的工作。它在Lua虚拟机中注册了钩子函数，每次Lua Call 和 Return 的时候都会触发回调。在每次回调的时候，在C里维护了一颗 限制层级的多节点树 ，由C#主动来取这颗树。每帧都取每帧都清空，即是逐帧统计。每隔一段时间取，但不清空，即是累计模式。 二、 LuaProfiler的UnityEditorEditor的主体是一组递归绘制的foldout控件，在Editor上显示出一个树状结构。LuaProfiler能实时地根据调用层级，然后通过各个按钮实现各种规则排序。这和UnityProfiler相同，想必大家不会陌生。另外LuaProfiler不仅提供了和UnityProfiler一样的逐帧模式，还提供了统计模式和累计模式。在累计模式下，会把每一帧的内存分配累加起来，以树状结构的方式展示出来。而统计模式则是把每一个函数的内存分配累加起来，以Top10的形式展现出来。统计模式不关心调用层级，只关心所有函数中哪些函数分配的内存最多。在这样一个工具的帮助下，RO的内存分配优化变得格外简单、高效。 三、 常见优化：string.gsub和string.gmatch在我们项目中，用这两个string库函数完成了一个计算中文个数、长度的工具函数。但是容易被忽略的是，string.gsub和string.gmatch会产生大量的子串，这些子串都会开辟一片内存，而我们根本用不上这些子串。我发现函数1在很多项目中都普遍存在，但是用函数2会更好一些。 function getTextLen(str) local result = 0 for uchar in string.gmatch(str, \"[%z\\1-\\127\\194-\\244][\\128-\\191*\") do result = result + 1 end return result end function getTextLen(str) local byteLen = #str local strLen = 0 local i = 1 local curByte local count = 1 while i &lt;= byteLen do curByte = string.byte(str, i) count = 1 if curByte &gt; 0 and curByte &lt;= 127 then count = 1 elseif curByte &gt;= 192 and curByte &lt; 223 then count = 2 elseif curByte &gt;= 224 and curByte &lt; 239 then count = 3 elseif curByte &gt;= 240 and curByte &lt; 247 then count = 4 end i = i + count strLen = strLen + 1 end return strLen end 四、 常见优化：Lua中string是不可变值这一点也经常被大家忘记，哪怕是写Lua的老手。在以下代码中，因为Lua的string是不可变值，每次拼接都会产生一串新的字符串。第6行会产生”仙境”、”仙境传”、”仙境传说”一共3串字符串，但是我们只是需要第三串而已（“仙”字被Lua背部重用了）。这无形中就多开辟了一部分内存，我们可以对以下代码进行优化，从而避免浪费。这种疏忽经常出现在 I/O文件、聊天频道、处理配置描述字段时发生。 1 local tab = { \"R\", \"O\", \"仙\", \"境\", \"传\", \"说\" } 2 3 function getName() 4 local ret = \"\" 5 for i = 3, #tab do 6 ret = ret .. tab[i] 7 end 8 return ret 9 end 10 11 function getName() 12 return table.concat(tab, 3, #tab) 13 end 五、 常见优化：内存池如果想降低内存分配速度，使用内存池复用对象是必不可少的。在Lua内存池的使用过程中，最容易出现的问题是，忘了放回池子以及池子大小不合理。 总结全文上下，用到的技术都不难，相信大家都能搞定。在这里主要是和大家分享一下拿到原始数据后，如何处理过滤数据、信息的经验，从而更快更准确地定位问题。如果大家有更好更精准的处理数据、过滤信息的方法请不吝赐教。 邮箱 inkiu0@gmail.com QQ 286553528 UWA群内ID ink_U0 预告下一次将会给大家带来LuaProfiler的CPU优化部分，在这部分内容主要有： 用多线程缓解DeepProfile数造成的卡顿 Lua的CPU时间优化经验 Lua的CPU时间到底消耗在哪一块，Lua是不是不堪大任呢？","tags":[{"name":"Unity","slug":"Unity","permalink":"blog.codershu.com/tags/Unity/"},{"name":"Lua","slug":"Lua","permalink":"blog.codershu.com/tags/Lua/"}]},{"title":"LuaMemory的实现(二)","date":"2017-03-17T12:46:00.000Z","path":"2017/03/17/luamemory_editor/","text":"LeakMemoryEditor的编写LuaMemory的核心是C库的编写，编写好C库以后，其他的周边的Editor的编写会比较简单，但是也最见策略。LuaMemory的编辑器主要有三大功能： Snapshot的逻辑操作 可以对两个或多个采样(Snapshot)之间使用逻辑操作，求交集和补集。这样可以很容易地缩小范围，更容易地定位泄露。 内存的树状结构 把所有地内存按树状结构展现出来，根节点是_G或者Registry。如果某一项被多次引用，则把他挂在层级最浅地那个节点上， _G层级1为最浅。 数据存在另一个lua_state 如果把数据储存在当前地lua_state中，则要很小心地避免其对采样地影响。而在C中另起一个state来储存则不存在这个问题。 Snapshot地逻辑操作 交集(与操作)对2个或2个以上的Snapshot求交集，得到在这些Snapshot中都存在的内存项。并储存在一个新的Snapshot中，这个新的Snapshot也能进行逻辑操作和输出。 补集(求增量)对2个Snapshot A B求补集，得到在B中但是不在A中的内存项，并储存在一个新的Snapshot中。 内存的树状结构 获取C库采集的数据C库采集完成的数据，按先进后出的顺序储存在另外一个lua_state中，我们通过getlog接口来获取储存在pL中的某次采样。假设我们采集了5次，那么pL的栈结构为： /*pL栈当前情况 -------------------- 5 第一次采样 4 第二次采样 3 第三次采样 2 第四次采样 1 第五次采样 -------------------- */ 获取到的Snapshot是一个table结构，key为该内存项的指针，value为一个table，储存了lua和c#需要的信息。 -- Snapshot中每一项的结构如下 Snapshot[pointer] = { [\"count\"] = number, [\"type\"] = string, [\"level\"] = number, [\"parent\"] = pointer, [\"size\"] = number/byte, [\"infos\"] = { string, ... }, [\"child_list\"] = { pointer, ... } } 构造树状结构因为需要实现某个子集的树状结构，而且子集中的信息不全。那么我们就需要从这个子集的全集中查找信息，以填充子集的树状结构。 ABC…交集的父集为A AB补集的父集为B 实现细节：每一项都用while一直查询到parent为nil，取得该项的完整调用。然后再从根节点开始，在Map中查找，没找到就新建一个节点，找到了就进入改节点，然后继续找自身的下一级。 传输调整后的数据给C#把得到的数据做了处理以后生成一串jsonstring传给c#，然后c#解析出一个树状的Dictonary。c#中有一个递归的结构LeakItemNode，用来储存数据。LuaMemoryEditor持有根节点m_Root //... //一些从json中解析出来的数据 //... List&lt;LeakItemNode&gt; childList = list&lt;LeakItemNode&gt;(); 另一个lua_state在C中用一个静态变量储存起来的lua_state *pL，所有的采样数据都储存在其中。另外提供3个重要的接口用以操作该栈： insert(idx)把栈顶的Snapshot插入idx处 pop(num)出栈num个Snapshot clear清空栈","tags":[{"name":"Unity","slug":"Unity","permalink":"blog.codershu.com/tags/Unity/"},{"name":"Lua","slug":"Lua","permalink":"blog.codershu.com/tags/Lua/"}]},{"title":"LuaMemory的实现(一)","date":"2017-02-24T06:02:00.000Z","path":"2017/02/24/luamemory_capi/","text":"LuaC库的编写lua_next(lua_State *L, int idx)lua_next 先把 table ( lua 栈中 idx 所指的 table )的下一索引弹出，再把 table 当前索引的值弹出。没有数据了返回0，有数据返回非0。 local test_table = { [\"a\"] = 1, [\"b\"] = 2, [\"c\"] = \"ccc\" } lua_pushnil(L); /*lua栈当前情况 -------------------- -1 nil -2 test_table -------------------- */ while(lua_next(L, -2) != 0) { /*lua栈当前情况 -------------------- -1 value -2 key -3 test_table -------------------- */ if(lua_isnumber(L,-2)) cout&lt;&lt;\"key:\"&lt;&lt;lua_tonumber(L,-2)&lt;&lt;'\\t'; else if(lua_isstring(L,-2)) cout&lt;&lt;\"key:\"&lt;&lt;lua_tostring(L,-2)&lt;&lt;'\\t'; if(lua_isnumber(L,-1)) cout&lt;&lt;\"value:\"&lt;&lt;lua_tonumber(L,-1)&lt;&lt;endl; else if(lua_isstring(L,-1)) cout&lt;&lt;\"value:\"&lt;&lt;lua_tostring(L,-1)&lt;&lt;endl; /*lua栈当前情况 -------------------- -1 value -2 key -3 test_table -------------------- */ lua_pop(L, 1); /*lua栈当前情况 -------------------- -1 key -2 test_table -------------------- */ } /*lua栈当前情况 -------------------- -1 test_table -------------------- */ 需要注意的是 lua_next 先把 table 的下一索引弹出 , 下一索引是相对于上一个索引的。所以我们在循环开始的时候入栈了nil，表示我们是从头开始遍历table。而在循环中，每次都保留了上次的key。直到 lua_next 返回0, 表示 table 已经遍历完, 此时退出循环, 最后一个 key 才出栈。 lua_newtable创建一个 table 并压入栈顶。 lua_rawgeti(L, LUA_REGISTRYINDEX, LUA_RIDX_GLOBALS)LUA_REGISTRYINDEX 是lua注册表的伪索引, LUA_RIDX_GLOBALS 是lua中全局环境即 _G 在注册表中的索引。这行代码获取得了 _G 并压入栈顶。 lua_pushvalue复制栈上索引处的值，并压入栈顶。lua_pushvalue(L, -2), 把 -2 位置的值复制一份压入到栈顶。 /*lua栈当前情况 -------------------- -1 level_111 -2 level_222 -------------------- */ lua_pushvalue(L, -2); /*lua栈当前情况 -------------------- -1 level_222 -2 level_111 -3 level_222 -------------------- */ lua_insert将栈顶的元素压入索引处，索引处到栈顶的元素依次往上移，栈的大小不变。 for(int i = 1; i &lt; 6; i++) { lua_pushnumber(L, i); } /*lua栈当前情况 -------------------- -1 5 -2 4 -3 3 -4 2 -5 1 -------------------- */ lua_insert(L, 2); /*lua栈当前情况 -------------------- -1 4 -2 3 -3 2 -4 5 -5 1 -------------------- */ Lua _G内存结构Lua内存结构Lua内以下类型都是属于GCObject，是有gc方法的。 table [table]self [table]metatable [object]kv function [object]upvalue [lcl/ccl]self thread [object]stack userdata [table]metatable [table]uservalue string [TString]self print在编写统计代码的时候，我们时常会用到测试代码。但是需要注意的是，有些测试代码本身就会产生一些内存，以误导我们的测试。比如print，我猜测是因为每次print都产生了一个函数上值。所以我们在print后需要手动 collectgarbage() 。 tabletable可能引用的内容 metatable metatable即该table的原表，一定是一个table。 非weak的key key可以是任意类型 非weak的value value可以是任意类型 table大小计算//单位为byte size = sizeof(Table) + sizeof(TValue) * t-&gt;sizearray + sizeof(Node) * sizenode(t) sizeof(Table) = 56 sizeof(TValue) = 16 sizeof(Node) = 32 sizenode(t) table的hashtable部分长度，值总是2的幂，a power of 2。hashtable.len为0时，sizenode为1，hashtable.len为1时，sizenode为1。所以想要分辨出0和1需要判断一下t-&gt;lastfress，定义宏如下： #define isdummy(t) ((t)-&gt;lastfree == NULL) functionfunction可能引用的内容 upvalue upvalue可以是任意类型 本身 function本身可能为Luafunction和Cfunction function大小计算在lua中function分为 LColsure 和 CColsure，即Lua函数和C函数。 ttisCclosure(o) ? sizeCclosure(cl-&gt;c.nupvalues) : sizeLclosure(cl-&gt;l.nupvalues) //sizeCclosure(n) = sizeof(CClosure) + sizeof(TValue)* (n-1) //sizeLclosure(n) = sizeof(LClosure) + sizeof(TValue)* (n-1) sizeof(CClosure) = 48 sizeof(LClosure) = 40 threadthread可能引用的类型 stack stack中的值，以及这些值的local变量 thread大小计算lua中的thread即为Coroutine (sizeof(lua_State) + sizeof(TValue) * th-&gt;stacksize + sizeof(CallInfo) * th-&gt;nci); userdatauserdata可能引用的类型 metatable userdata可能有自己的元表 uservalue userdata的内容，是一个table类型。 userdata大小计算sizeudata(uvalue(o)); stringstring大小计算//string分为LUA_TLNGSTR和LUA_TSHRSTR case LUA_TSHRSTR: sizelstring(ts-&gt;shrlen); case LUA_TLNGSTR: sizelstring(ts-&gt;u.lnglen);","tags":[{"name":"Unity","slug":"Unity","permalink":"blog.codershu.com/tags/Unity/"},{"name":"Lua","slug":"Lua","permalink":"blog.codershu.com/tags/Lua/"}]},{"title":"Lua性能分析器的实现","date":"2017-02-21T15:44:00.000Z","path":"2017/02/21/luaprofiler/","text":"这个Profiler主要由3部分组成： C类重写luaC库钩子函数 lua类在钩子的回调中采集信息，并生成报表供C#使用。 C#类每帧取得数据存下来，并每0.5s取最新一帧显示在编辑器中。编辑器窗口完成一些自有功能。 编写lua第三方C库想要编写一个第三方的luaC库，主要需要以下几点知识： lua栈的概念 lua栈的常用操作 C代码示例 lua栈的概念lua可以作为一个独立运行的程序，也可以作为一个嵌入其他应用的程序库。但是在游戏开发中，lua基本都是作为一个嵌入式的语言存在的。同时把C作为lua的第三方库调用，C和lua通信的API称为C API。 C API 是一个 C 代码与 Lua 进行交互的函数集。他有以下部分组成：读写 Lua 全局 变量的函数,调用 Lua 函数的函数，运行 Lua 代码片断的函数，注册 C 函数然后可以在 Lua 中被调用的函数，等等。 而 C 和 lua 交互是基于一个虚拟的栈，所有的API调用都是对这个栈上的值的操作。lua的虚拟栈是为了解决lua数据和其他语言数据交互而设计的，否则我们就要面对这两个问题： 动态类型和静态类型不匹配 手动管理内存和自动管理内存 lua栈的常用操作lua_open()创建一个luastate，即lua的运行环境。但这个环境不包括任何预定义的函数，比如 print 。lualib.h定义了我们打开其他标准库的方法，比如 luaopen_io(L) 和 luaopen_table(L) 可以创建io table和table table，并把I/O函数、table操作函数注册到lua环境中（比如io.write、table.insert）。 lua_push*压入元素，把数据压入栈中。例如lua_pushstring、lua_pushnil等等。 lua_is*查询函数，判断数据类型。例如lua_isnumber、lua_istable、lua_isstring、lua_isboolean。 lua_to*取值函数，从栈中取得值。例如lua_tonumber、lua_tostring等。 其他lua栈操作 lua_gettop lua_settop lua_pushvalue lua_remove lua_insert lua_replace stack_dumpdump整个堆栈的内容 C代码示例static const char *const hooknames[] = {\"call\", \"return\", \"line\", \"count\", \"tail call\"}; static void hook(lua_State *L, lua_Debug *db) { int event; //入栈light userdata 索引为1 lua_pushlightuserdata(L, (void *)p); //取值LUA_REGISTRYINDEX，并绕过__index。取得注册的函数后，将函数移到栈顶，即索引为2。 lua_rawget(L, LUA_REGISTRYINDEX); event = db-&gt;event; //入栈string，索引为3。 lua_pushstring(L, hooknames[event]); //得到debug信息 lua_getinfo(L, \"nS\", db); if(*(db-&gt;what) == 'C') { //如果是C函数，入栈此string，索引为4。 lua_pushfstring(L, \"[C?%s]\", db-&gt;name); } else { //如果不是C函数，入栈此string，索引为4。 lua_pushfstring(L, \"%s-%d\", db-&gt;short_src, db-&gt;linedefined &gt; 0 ? db-&gt;linedefined : 0); } //调用索引为2的函数，即lua注册的hook回调。 lua_call(L, 2, 0); //C函数退出，并清空当前虚拟栈。 } -- 这时候回调给lua的函数如下 function OnHook(event, id) -- event 即索引为3的string -- id 即索引为4的string end lua5.3第三方库的注册//这是lua5.3新版的写法 LUAMOD_API int luaopen_profiler(lua_State *L) { luaL_checkversion(L); luaL_Reg l[] = { { \"sethook\", profiler_set_hook }, { NULL, NULL } }; luaL_newlib(L, l); lua_setglobal(L, \"profiler\"); return 1; } //两者兼容的写法 LUALIB_API int luaopen_bitLib(lua_State *L) { luaL_Reg l[] = { { \"sethook\", profiler_set_hook }, { NULL, NULL } }; #if LUA_VERSION_NUM &lt; 502 luaL_register(L, \"profiler\", l); lua_pop(L, 1); #else luaL_newlib(L, l); lua_setglobal(L, \"profiler\"); #endif return 1; } 编译动态链接库mac下用gcc生成动态链接库和linux有点不同 gcc -c profiler.c;gcc -O2 -bundle -undefined dynamic_lookup -o profiler.so profiler.o 编写lua函数lua代码的编写比较简单，主要有以下一些不常用的用法需要注意。 引入C库-- 如果我们设置了global名字就可以用全局的名字调用C库里的函数 require \"profiler\" local sethook = profiler.sethook -- 如果我们没有设置global local p = require \"profiler\" local sethook = p.sethook sethookdebug.sethook(onhook, ‘crl’)的第一个参数是回调函数，第二个参数是事件的mask字符串。 LUA_MASKCALL 0在解释器调用一个函数时被调用。 钩子将于 Lua 进入一个新函数后，函数获取参数前被调用。 LUA_MASKRET 1在解释器从一个函数中返回时调用。 钩子将于 Lua 离开函数之前的那一刻被调用。执行到returnhook的时候已经函数已经退出了。 LUA_MASKLINE 2在解释器准备开始执行新一行代码，或者跳转到这行代码（即使是同一行跳转）时被调用。 LUA_MASKCOUNT 3在解释器执行一个lua函数的cout指令时被调用。 LUA_HOOKTAILCALL 4在解释器执行一个尾调用的时候触发，尾调用对应的return同时也是它父级的return。回调函数onhook(event, line)第一个参数是事件类型，值为call, tail call, return。line参数是可选的。当我们调用了sethook(onhook, ‘cr’)的时候，第一个触发的钩子是return sethook。同样当我们调用debug.sethook()来停止的时候，最后一个触发的钩子是call sethook。getinfodebug.getinfo(2, ‘Sn’)的第一个参数是要查询的调用层级，第二个参数是要查询的数据的掩码，具体可以查询lua手册去了解。如果得到的信息不准确，比如得到一个C#的函数，往往信息都不对。这个时候我们可以往上回溯，即getinfo(level, ‘Sn’)，加大level。 报表为了方便C#中取得我们采集的信息，lua被设计成每次report时： 暂停hook 整理数据 返回所有累计记录的数据 重启hook，并清空数据。 编写C#类C#主要由2部分组成，处理数据和更新UI。 处理数据每帧的Update会从lua中取得最新的数据，然后缓存下来。每0.5s取最新的数据解析到树状结构中，由于在lua返回的已经是一个树状结构的json字符串了，所以解析的过程比较简单，一个递归就可以解决了。已存在的节点保存了flodout状态，所以当我们解析到一个已存在节点的时候需要的是更新OnGUI每帧编辑器都会尝试绘制树状结构，而当我们更新树状结构数据后，OnGUI才真正显示出新的数据。OnGUI每帧都要绘制，要不然点击事件等等都不会响应了，所有一切视图上的操作反馈都以来OnGUI的更新OnGUI不同的是在于各种Editor下控件的使用，还可以利用反射去的Unity内置的各种图标，使得编辑器的表现形式更多样。 编辑器的类名要和文件名一致，要不然重启unity的时候会出现加载不出窗口的情况，显示 failed to load 后记实践出真知，只有做了以后才理解的更深刻。要不然只是侃侃而谈，流于表面罢了。这次写编辑器让我对lua的使用更深入了一些，虽然还谈不上什么造诣。但是至少比普通人了解的更多、更深了，了解的更深入对我平时写代码并没有什么帮助，但是当遇到问题的时候，那么我能探究的深度就比别人更深了。总之来说，就是能查的bug更多了，范围更广了。深切感觉到，技术上想要牛逼，全靠同行衬托……","tags":[{"name":"Unity","slug":"Unity","permalink":"blog.codershu.com/tags/Unity/"},{"name":"Lua","slug":"Lua","permalink":"blog.codershu.com/tags/Lua/"}]},{"title":"Slua的优化初探","date":"2017-02-05T15:27:00.000Z","path":"2017/02/05/sluaunitytransform.position/","text":"看了UWA的blog以后，了解到了tolua对c#对象取值赋值的过程。并且发现slua对比tolua在test1里性能是tolua的6倍，所以很好奇slua做了哪些优化。 tolua取值赋值的过程 slua的取值赋值过程 取出object的缓存 ObjectCache oc = ObjectCache.get(l); 取得c#中的index然后再ObjectCache里面查找 cache.get(index, out o)，类似tolua中的Translator，都是从缓存中取出object int index = LuaDLL.luaS_rawnetobj(l, p); object o; if (index != -1 &amp;&amp; cache.get(index, out o)) { return o; } 从栈中取出3个float组成Vector3 UnityEngine.Vector3 v; checkType(l,2,out v); static public bool checkType(IntPtr l, int p, out Vector3 v) { float x, y, z; if(LuaDLL.luaS_checkVector3(l, p, out x, out y, out z)!=0) throw new Exception(string.Format(&quot;Invalid vector3 argument at {0}&quot;, p)); v = new Vector3(x, y, z); return true; } 赋值给position self.position=v; slua相比tolua做了哪些优化 赋值是在c#中完成的而不是取得object后把index构造成userdata后在lua中赋值 返回的object缓存起来了，没有频繁地GC 还有那些优化的余地 lua给c#传递3个float而不是一个内容为{x,y,z}的table","tags":[{"name":"Unity","slug":"Unity","permalink":"blog.codershu.com/tags/Unity/"},{"name":"Lua","slug":"Lua","permalink":"blog.codershu.com/tags/Lua/"},{"name":"Slua","slug":"Slua","permalink":"blog.codershu.com/tags/Slua/"}]},{"title":"运动模糊 ","date":"2017-01-25T16:00:00.000Z","path":"2017/01/26/MotionBlur/","text":"#MotionBlur运动模糊 首先为accumulationTexture进行一个恢复操作，以取得上一步混合得到的纹理。 然后用shader把原图像和上一步的纹理进行混合 最后把混合后的纹理显示在屏幕上。 accumulationTexture.MarkRestoreExpected(); material.SetFloat(&quot;_BlurAmount&quot;, 1.0f - blurAmount); Graphics.Blit(src, accumulationTexture, material); Graphics.Blit(accumulationTexture, dest); shader混合图像的方式为(last.rgb BlurAmount + src.rgb (1 - blurAmount), last.a) Shader &quot;UnityShaderLearning/MotionBlur&quot; { Properties { _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; {} _BlurAmount(&quot;Blur Amount&quot;, FLoat) = 1.0 } SubShader { CGINCLUDE #include &quot;UnityCG.cginc&quot; sampler2D _MainTex; fixed _BlurAmount; struct v2f { float4 pos : SV_POSITION; half2 uv : TEXCOORD0; }; v2f vert(appdata_img v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.uv = v.texcoord; return o; } fixed fragRGB(v2f i) : SV_Target { return fixed4(tex2D(_MainTex, i.uv).rgb, _BlurAmount); } half4 fragA(v2f i) : SV_Target { return tex2D(_MainTex, i.uv); } ENDCG ZTest Always Cull Off ZWrite Off Pass { Blend SrcAlpha OneMinusSrcAlpha ColorMask RGB CGPROGRAM #pragma vertex vert #pragma fragment fragRGB ENDCG } Pass { Blend One Zero ColorMask A CGPROGRAM #pragma vertex vert #pragma fragment fragA ENDCG } } Fallback Off }","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"bloom效果","date":"2017-01-24T16:00:00.000Z","path":"2017/01/25/bloom/","text":"bloom是模拟真实相机，较亮的部分扩散到周围，造成一种朦胧的感觉。 先用第一个pass筛选出原图中较亮的部分 然后在第二和第三个pass中把较亮的图像进行高斯模糊 最后在第四个pass中把模糊后的亮部和原图进行混合得到bloom效果 12345678910111213141516171819202122232425262728 void OnRenderImage(RenderTexture src, RenderTexture dest)&#123; if (material != null) &#123; material.SetFloat(\"_LuminanceThreshold\", luminanceThreshold); int rtW = src.width / downSample; int rtH = src.height / downSample; RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, 0); buffer0.filterMode = FilterMode.Bilinear; Graphics.Blit(src, buffer0, material, 0); for (int i = 0; i &lt; iterations; i++) &#123; material.SetFloat(\"_BlurSize\", 1.0f + i * blurSpread); RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0); Graphics.Blit(buffer0, buffer1, material, 1); RenderTexture.ReleaseTemporary(buffer0); buffer0 = buffer1; &#125; material.SetTexture(\"_Bloom\", buffer0); Graphics.Blit(src, dest, material, 3); RenderTexture.ReleaseTemporary(buffer0); &#125; else &#123; Graphics.Blit(src, dest); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293 Shader \"UnityShaderLearning/Bloom\"&#123; Properties &#123; _MainTex (\"Base (RGB)\", 2D) = \"white\" &#123;&#125; _Bloom (\"Bloom (RGB)\", 2D) = \"black\" &#123;&#125; _LuminanceThreshold(\"Luminance Threshold\", Float) = 0.5 _BlurSize(\"Blur Size\", Float) = 1.0 &#125; SubShader &#123; CGINCLUDE #include \"UnityCG.cginc\" sampler2D _MainTex; half4 _MainTex_TexelSize; sampler2D _Bloom; float _LuminanceThreshold; float _BlurSize; struct v2f &#123; float4 pos : SV_POSITION; half2 uv : TEXCOORD0; &#125;; v2f vertExtractBright(appdata_img v) &#123; v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.uv = v.texcoord; return o; &#125; fixed luminance(fixed4 color) &#123; return 0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b; &#125; fixed4 fragExtractBright(v2f i) : SV_Target &#123; fixed4 c = tex2D(_MainTex, i.uv); fixed val = clamp(luminance(c) - _LuminanceThreshold, 0.0, 1.0); return c * val; &#125; struct v2fBloom &#123; float4 pos : SV_POSITION; half4 uv : TEXCOORD0; &#125;; v2fBloom vertBloom(appdata_img v) &#123; v2fBloom o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.uv.xy = v.texcoord; o.uv.zw = v.texcoord; #if UNITY_UV_STARTS_AT_TOP if (_MainTex_TexelSize.y &lt; 0.0) o.uv.w = 1.0 - o.uv.w; #endif return o; &#125; fixed4 fragBloom(v2fBloom i) : SV_Target &#123; return tex2D(_MainTex, i.uv.xy) * tex2D(_Bloom, i.uv.zw); &#125; ENDCG ZTest Always Cull Off ZWrite Off Pass &#123; CGPROGRAM #pragma vertex vertBloom #pragma fragment fragBloom ENDCG &#125; UsePass \"UnityShaderLearning/GaussianBlurShader/GAUSSIAN_BLUR_VERTICAL\" UsePass \"UnityShaderLearning/GaussianBlurShader/GAUSSIAN_BLUR_HORIZONTAL\" Pass &#123; CGPROGRAM #pragma vertex vertBloom #pragma fragment fragBloom ENDCG &#125; &#125; Fallback Off&#125;","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"高斯模糊","date":"2017-01-21T16:00:00.000Z","path":"2017/01/22/gaussianblur/","text":"首先创建了一块1/downSample屏幕大小的buffer存入当前屏幕图像，然后设置滤波模式为双线性采样。这样需要处理的像素是原来的1/downSample。然后多次进行高斯模糊，逐次增大_BlurSize。 void OnRenderImage(RenderTexture src, RenderTexture dest) { if(material != null) { int rtW = src.width; int rtH = src.height; RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, 0); buffer0.filterMode = FilterMode.Bilinear; Graphics.Blit(src, buffer0); for(int i = 0; i &lt; iterations; i++) { material.SetFloat(&quot;_BlurSize&quot;, 1.0f + i * blurSpread); RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0); Graphics.Blit(buffer0, buffer1, material, 0); RenderTexture.ReleaseTemporary(buffer0); buffer0 = buffer1; buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0); Graphics.Blit(buffer0, buffer1, material, 1); RenderTexture.ReleaseTemporary(buffer0); buffer0 = buffer1; } Graphics.Blit(buffer0, dest); RenderTexture.ReleaseTemporary(buffer0); } else { Graphics.Blit(src, dest); } } 这个shader的顶点着色器用来分别计算横竖2组像素位置，片元着色器是相同的。因为高斯模糊的卷积核权重是对称的，所以可以只用一个长度为3的数组描述。顶点shader输入的uv坐标都是从当前点平移1-2个纹素得到的，比如得到当前点右边相邻的这个格子uv + (texelSiz * 1, 0) fixed4 fragBlur(v2f i) : SV_Target { float weight[3] = {0.4026, 0.2442, 0.0545}; fixed3 sum = tex2D(_MainTex, i.uv[0]).rgb * weight[0]; for (int it = 1; it &lt; 3; it++) { sum += tex2D(_MainTex, i.uv[it]).rgb * weight[it]; sum += tex2D(_MainTex, i.uv[2 * it]).rgb * weight[it]; } return fixed4(sum, 1.0); }","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"Sobel算子边缘检测","date":"2017-01-16T16:00:00.000Z","path":"2017/01/17/sobel/","text":"用Sobel算子来进行边缘检测应该知道除了Sobel算子以外还有几种常用的算子。 Roberts $$\\left[\\begin{matrix}-1 &amp; 0 \\ 0 &amp; 1\\end{matrix}\\right]$$$$\\left[\\begin{matrix}0 &amp; -1 \\1 &amp; 0\\end{matrix}\\right]$$ Prewitt $$\\left[\\begin{matrix}-1 &amp; -1 &amp; -1 \\ 0 &amp; 0 &amp; 0 \\ 1 &amp; 1 &amp; 1\\end{matrix}\\right]$$$$\\left[\\begin{matrix}-1 &amp; 0 &amp; 1 \\-1 &amp; 0 &amp; 1 \\-1 &amp; 0 &amp; 1\\end{matrix}\\right]$$ Sobel $$\\left[\\begin{matrix}-1 &amp; -2 &amp; -1 \\0 &amp; 0 &amp; 0 \\1 &amp; 2 &amp; 1\\end{matrix}\\right]$$$$\\left[\\begin{matrix}-1 &amp; 0 &amp; 1 \\-2 &amp; 0 &amp; 2 \\-1 &amp; 0 &amp; 1\\end{matrix}\\right]$$ 我们取得一个纹素的大小， 即1/texelSize。然后根据现在的纹理坐标前后左右偏移一个像素，得到9个方向的纹理坐标。然后用Sobel函数算得该纹理坐标的卷积值 _EdgeOnly = 0时显示原图像和边缘的叠加图像，即withEdgeColor _EdgeOnly = 1时只显示边缘，其他部分为背景色，即只显示onlyEdgeColor v2f vert(appdata_img v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); half2 uv = v.texcoord; o.uv[0] = uv + _MainTex_TexelSize.xy * half2(-1, -1); o.uv[1] = uv + _MainTex_TexelSize.xy * half2(0, -1); o.uv[2] = uv + _MainTex_TexelSize.xy * half2(1, -1); o.uv[3] = uv + _MainTex_TexelSize.xy * half2(-1, 0); o.uv[4] = uv + _MainTex_TexelSize.xy * half2(0, 0); o.uv[5] = uv + _MainTex_TexelSize.xy * half2(1, 0); o.uv[6] = uv + _MainTex_TexelSize.xy * half2(-1, 1); o.uv[7] = uv + _MainTex_TexelSize.xy * half2(0, 1); o.uv[8] = uv + _MainTex_TexelSize.xy * half2(1, 1); return o; } fixed luminance(fixed4 color) { return 0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b; } half Sobel(v2f i) { const half Gx[9] = { -1, -2, -1, 0, 0, 0, 1, 2, 1 }; const half Gy[9] = { -1, 0, 1, -2, 0, 2, -1, 0, 1 }; half texColor; half edgeX = 0; half edgeY = 0; for (int it = 0; it &lt; 9; it++) { texColor = luminance(tex2D(_MainTex, i.uv[it])); edgeX += texColor * Gx[it]; edgeY += texColor * Gy[it]; } half edge = 1 - abs(edgeX) - abs(edgeY); return edge; } fixed4 frag(v2f i) : SV_Target { half edge = Sobel(i); fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[4]), edge); fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge); return lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly); }","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"Lua迭代器和遍历","date":"2017-01-15T16:00:00.000Z","path":"2017/01/16/luaIter/","text":"1. Lua遍历在用Lua开发过程中经常会用到一些库, 最近看到了Map类中的FindIf方法。 感觉用的很巧妙, 遂分析学习一下。FindIf方法我用原生的Lua实现了一遍, 去除了自定义的一些方法, 便于理解。 Map = {} Map.data = {} local hank = { name = &quot;hank&quot;, weight = 75 } local marry = { name = &quot;marry&quot;, weight = 50 } table.insert(Map.data, hank) table.insert(Map.data, marry) Map.Comparator = function(classNumber, equalValue) if classNumber == nil or equalValue == nil then print(&quot;参数错误! classNumber = &quot; .. tostring(classNumber) .. &quot;equalValue = &quot; .. tostring(equalValue)) end local func = function(equalValue) local comparator = function(data) return equalValue == data[classNumber] end return comparator; end return func(equalValue) end Map.Find = function(classNumber, equalValue) local comparator = Map.Comparator(classNumber, equalValue) local find = nil local index = -1; if Map.data ~= nil and #Map.data &gt; 0 then for i = 1, #Map.data do if comparator(Map.data[i]) then find = Map.data[i] index = i; break; end end end return find, index; end -- 使用示例 print(Map.Find(&quot;name&quot;, &quot;hank&quot;)) print(Map.Find(&quot;name&quot;, &quot;marry&quot;)) print(Map.Find(&quot;weight&quot;, 50)) 使用ideone运行以后输出: Success time: 0 memory: 2844 signal:0 table: 0x8573b10 1 table: 0x8573b68 2 table: 0x8573b68 2 在这里推荐一下这个在线的ide。 1.1 疑惑Map.Comparator返回的是什么?调用Map.Comparator后做了2件事: 声明一个局部变量func指向一个匿名函数function(equalValue) 调用func, 返回func的返回值。所以返回值为local comparator, 即function(data)。 Map.Comparator中的data是什么?data为调用Map.Comparator的返回值时传入的参数。比如Map.Find中comparator(Map.data[i]), Map.data[i]即为data参数。 2. Lua迭代器 next的使用```local Map = {}Map.data = {1, 2, 3}Map.it = function() return next, Map.data, nilend – 使用示例for k,v in Map.it() do print(k..v)end 使用[ideone](http://ideone.com/)运行以后输出: &gt;Success time: 0 memory: 2844 signal:0 11 22 33 - ### 自定义迭代器 local Map = {}Map.data = {1, 2, 3}Map.iter = function(data, i) print(“i: “ .. i) i = i + 1 local v = data[i] if v then return i, v endendMap.v = 0Map.it = function() return Map.iter, Map.data, Map.vend – 使用示例for k,v in Map.it() do print(“Map.v: “ .. Map.v) print(k..v)end```使用ideone运行以后输出: Success time: 0 memory: 2844 signal:0i: 0Map.v: 011i: 1Map.v: 022i: 2Map.v: 033i: 3 疑惑 next是什么next是Lua函数库中默认函数, 返回一个table的下一个值。 next (table [, index]) 运行程序来遍历表中的所有域。 第一个参数是要遍历的表，第二个参数是表中的某个键。 next 返回该键的下一个键及其关联的值。 如果用 nil 作为第二个参数调用 next 将返回初始键及其关联值。 当以最后一个键去调用，或是以 nil 调用一张空表时， next 返回 nil。 如果不提供第二个参数，将认为它就是 nil。 特别指出，你可以用 next(t) 来判断一张表是否是空的。 索引在遍历过程中的次序无定义， 即使是数字索引也是这样。 （如果想按数字次序遍历表，可以使用数字形式的 for 。） 当在遍历过程中你给表中并不存在的域赋值， next 的行为是未定义的。 然而你可以去修改那些已存在的域。 特别指出，你可以清除一些已存在的域引用自云风翻译的Lua5.3手册 for in是怎么使用这三个返回值的for in的完整形式应该是for k,v in f, s, v do, 其中f是迭代器工厂函数, s为状态/数据, v为迭代器初始值。第一次调用工厂函数生成一个迭代器, iter = f(s, v)后面每次调用迭代器iter其中data, i, v作为闭包数据保存了下来, 每次调用时i+1。 i三次迭代分别是什么值第一次i为Map.v第二次i为第一次的值保存下来后 + 1 = 2第三次i为第二次的值保存下来后 + 1 = 3","tags":[{"name":"Lua","slug":"Lua","permalink":"blog.codershu.com/tags/Lua/"}]},{"title":"亮度饱和度对比度屏幕后处理效果","date":"2017-01-15T16:00:00.000Z","path":"2017/01/16/bscposteffects/","text":"以下是调节屏幕亮度饱和度对比度的关键代码，cs脚本挂在Camera上。 //给shader传对应的亮度/饱和度/对比度 void OnRenderImage(RenderTexture src, RenderTexture dest) { if(material != null) { material.SetFloat(&quot;_Brightness&quot;, brightness); material.SetFloat(&quot;_Saturation&quot;, saturation); material.SetFloat(&quot;_Contrast&quot;, contrast); Graphics.Blit(src, dest, material); } else { Graphics.Blit(src, dest); } } //fragment shader用csharp传来的值进行插值得到屏幕处理后的效果 fixed4 frag(v2f i) : SV_Target { fixed4 renderTex = tex2D(_MainTex, i.uv); fixed3 finalColor = renderTex.rgb * _Brightness; fixed luminance = 0.2125 * renderTex.r + 0.7154 * renderTex.g + 0.0721 * renderTex.b; fixed3 luminanceColor = fixed3(luminance, luminance, luminance); finalColor = lerp(luminanceColor, finalColor, _Saturation); fixed3 avgColor = fixed3(0.5, 0.5, 0.5); finalColor = lerp(avgColor, finalColor, _Contrast); return fixed4(finalColor, renderTex.a); }","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"透明测试","date":"2017-01-15T16:00:00.000Z","path":"2017/01/16/alphatest/","text":"AlphaTest上图为简单的AlphaTest，Alpha值小于0.55的颜色抛弃。判断的语法clip (texcoordColor.a - value)也可写作 123456789101112131415if((texcoordColor.a - value) &lt; 0.0)&#123; discard;&#125; ``` - 双面渲染 AlphaTest开启双面渲染也比较容易，只需要在`Tags=&#123; \"LightMode\"=\"ForwardBase\" &#125;`后添加一行`Cull Off`, 关闭剔除即可开启双面渲染。# 2. 透明混合(AlphaBlend)![](/assets/blogImg/UnityShader/QQ图片20161209005804.png)![](/assets/blogImg/UnityShader/QQ图片20161209005808.png) - AlphaBlend 在Pass中开启Blend即可开启透明混合，混合的公式为`混合颜色 = 当前物体Alpha * 当前颜色 + (1 - 当前Alpha) * 背景颜色` - AlphaBlendZWrite AlphaBlend的shader添加一个Pass即可开启深度写入 Pass{ZWrite OnColorMask 0} ![](/assets/blogImg/UnityShader/QQ图片20161211225510.png) `ColorMask 0`即关闭该Pass的颜色通道写入，即该Pass只执行了深度写入，然后在后续Pass中处理其他操作。开启ZWrite以后相比AlphaBlend关闭ZWrite能更好地体现前后关系。 - 双面渲染 ![](/assets/blogImg/UnityShader/QQ图片20161212001732.png) AlphaBlend的双面渲染要比AlphaTest的稍微复杂一些, 复制原来AlphaBlend的代码，写作2个Pass，分别剔除Front渲染背面和剔除Back渲染前面。 Pass{ Cull Front //原来AlphaBlend的代码}Pass{ Cull Back //原来AlphaBlend的代码} - Photoshop中AlphaBlend的几种常用模式 &gt;//正常(Normal)，透明度混合 Blend SrcAlpha OneMinusSrcAlpha &gt; &gt;//柔和相加(Soft Additive) Blend OneMinusDstColor One &gt; &gt;//正片叠底(multiply 相乘) Blend DstColor One &gt; &gt;//变暗(Darken) BlendOp Min Blend One One &gt; &gt;//变亮(Lighten) BlendOp Max Blend One One &gt; &gt;//滤色(Screen) Blend OneMinusDstColor One &gt;&gt;//等同于Blend One OneMinusSrcColor //等于D + S - D * S &gt; &gt;线性减淡(Linear Dodge) Blend One One Shader “UnityShaderLearning/AlphaTest”{ Properties { _Color (“Main Tint”, Color) = (1, 1, 1, 1) _MainTex (“Main Tex”, 2D) = “white”{} _Cutoff (“Alpha Cutoff”, Range(0, 1)) = 0.55 } SubShader { Tags { “Queue”=”AlphaTest” “IgnoreProjector” = “True” “RenderType”=”TransparentCutout”} Pass { Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; } CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; fixed _Cutoff; struct a2v { float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; float2 uv : TEXCOORD2; }; v2f vert(a2v v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(_Object2World, v.vertex).xyz; o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); return o; } fixed4 frag(v2f i) : SV_Target { fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); fixed4 texColor = tex2D(_MainTex, i.uv); clip (texColor.a - _Cutoff); fixed3 albedo = texColor.rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir)); return fixed4(ambient + diffuse, 1.0); } ENDCG } } FallBack &quot;Transparent/Cutout/VertexLit&quot; } Shader “UnityShaderLearning/AlphaBlend”{ Properties { _Color (“Main Tint”, Color) = (1, 1, 1, 1) _MainTex (“Main Tex”, 2D) = “white”{} _AlphaScale (“Alpha Scale”, Range(0, 1)) = 1 } SubShader { Tags { &quot;Queue&quot;=&quot;AlphaTest&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;TransparentCutout&quot;} Pass { Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; } ZWrite Off Blend SrcAlpha OneMinusSrcAlpha CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; fixed _AlphaScale; struct a2v { float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; float2 uv : TEXCOORD2; }; v2f vert(a2v v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(_Object2World, v.vertex).xyz; o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); return o; } fixed4 frag(v2f i) : SV_Target { fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); fixed4 texColor = tex2D(_MainTex, i.uv); fixed3 albedo = texColor.rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir)); return fixed4(ambient + diffuse, texColor.a * _AlphaScale); } ENDCG } } FallBack &quot;Transparent/VertexLit&quot; }```","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"广告牌","date":"2017-01-13T16:00:00.000Z","path":"2017/01/14/billboarding/","text":"我们根据设置的法线y方向偏移来得到偏移后的法线，然后和upDir叉乘得到右方向，最后用法线和右方向叉乘得到准确的upDir。最后把顶点坐标通过我们构造的矩阵进行变化，从而得到新的顶点坐标，最后转换到观察空间。我们就可以得到始终面向我们的物体。 Shader &quot;UnityShaderlearning/BillBoarding&quot; { Properties { _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; {} _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1) _VerticalBillboarding (&quot;Vertical Restraints&quot;, Range(0, 1)) = 1 } SubShader { Tags { &quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;DisableBatching&quot;=&quot;True&quot; } Pass { Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; } ZWrite Off Blend SrcAlpha OneMinusSrcAlpha Cull Off CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; sampler2D _MainTex; float4 _MainTex_ST; fixed4 _Color; fixed _VerticalBillboarding; struct a2v { float4 vertex : POSITION; float4 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float2 uv : TEXCOORD0; }; v2f vert(a2v v) { v2f o; float3 center = float3(0, 0, 0) float3 viewer = mul(_World2Object, float4(_WorldSpaceCameraPos, 1)); float3 normalDir = viewer - center; normalDir.y = normalDir.y * _VerticalBillboarding; normalDir = normalize(normalDir); float3 upDir = abs(normalDir.y) &gt; 0.99 ? float3(0, 0, 1) : float3(0, 1, 0); float3 rightDir = normalize(cross(upDir, normalDir)); upDir = normalize(cross(normalDir, rightDir)); floar3 centerOffs = v.vertex.xyz - center; floar3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y = normalDir * centerOffs.z; o.pos = mul(UNITY_MATRIX_MVP, float4(localPos, 1)); o.uv = TRANSFORM_TEX(v.texcoord,_MainTex); return o; } fixed4 frag(v2f i) : SV_Target { fixed4 c = tex2D (_MainTex, i.uv); c.rgb *= _Color.rgb; return c; } ENDCG } } Fallback &quot;Transparent/VertexLit&quot; }","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"顶点动画","date":"2017-01-10T16:00:00.000Z","path":"2017/01/11/uvanimationshader/","text":"对顶点进行位移以使得图片看起来像动画 _Frequency 是震动频率 _InvWaveLength 是波长的倒数 _Magnitude 是振幅 Shader &quot;UnityShaderLearning/UVAnimation&quot; { Properties { _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; {} _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1) _Magnitude(&quot;Distortion Magnitude&quot;, Float) = 1 _Frequency (&quot;Distortion Frequency&quot;, Float) = 1 _InvWaveLength (&quot;Distortion Inverse Wave Length&quot;, Float) = 10 _Speed (&quot;Speed&quot;, Float) = 0.5 } SubShader { Tags {&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;DisableBatching&quot;=&quot;True&quot; } Pass { Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; } ZWrite Off Blend SrcAlpha OneMinusSrcAlpha Cull Off CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;UnityCG.cginc&quot; sampler2D _MainTex; float4 _MainTex_ST; fixed4 _Color; float _Magnitude; float _Frequency; float _InvWaveLength; float _Speed; struct a2v { float4 vertex : POSITION; float2 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float2 uv : TEXCOORD0; }; v2f vert(a2v v) { v2f o; float4 offset; offset.yzw = float3(0.0, 0.0, 0.0); offset.x = sin(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude; o.pos = mul ( UNITY_MATRIX_MVP, v.vertex + offset); o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); o.uv += float2(0.0, _Time.y * _Speed); return o; } fixed4 frag(v2f i) : SV_Target { fixed4 c = tex2D(_MainTex, i.uv); c.rgb *= _Color.rgb; return c; } ENDCG } } Fallback &quot;Transparent/VertexLit&quot; }","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"序列帧动画","date":"2017-01-08T16:00:00.000Z","path":"2017/01/09/imagesequence/","text":"用shader对序列帧图片进行采样，以实现动画效果。 Shader &quot;UnityShaderLearning/ImageSequenceAni&quot; { Properties { _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1) _MainTex (&quot;Image Sequence&quot;, 2D) = &quot;white&quot;{} _HorizontalAmount (&quot;Horizontal Amount&quot;, Float) = 4 _VertcalAmount (&quot;Vertcal Amount&quot;, Float) = 4 _Speed (&quot;Speed&quot;, Range(1, 100)) = 30 } SubShader { Tags { &quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; } Pass { Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; } ZWrite Off Blend SrcAlpha OneMinusSrcAlpha CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;UnityCG.cginc&quot; fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; float _HorizontalAmount; float _VertcalAmount; float _Speed; struct a2v { float4 vertex : POSITION; float2 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float2 uv : TEXCOORD0; }; v2f vert(a2v v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); return o; } fixed4 frag(v2f i) : SV_Target { float time = floor(_Time.y * _Speed); float row = floor(time / _HorizontalAmount); float col = floor(time / _VertcalAmount); half2 uv = i.uv + half2(col, -row); uv.x /= _HorizontalAmount; uv.y /= _VertcalAmount; fixed4 color = tex2D(_MainTex, uv); color.rgb *= _Color; return color; } ENDCG } } FallBack &quot;Transparent/VertexLit&quot; }","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"程序纹理","date":"2017-01-05T16:00:00.000Z","path":"2017/01/06/proceduraltexturegeneration/","text":"性能消耗以秒计…不实用。 private Texture2D GenerateProceduralTexture() { Texture2D pTex = new Texture2D(textureWidth, textureWidth); float circleInterval = textureWidth / 4.0f; float radius = textureWidth / 10.0f; float edgeBlur = 1.0f / blurFactor; for(int w = 0; w &lt; textureWidth; w++) { for(int h = 0; h &lt; textureWidth; h++) { Color pixel = backgroundColor; for (int i = 0; i &lt; 3; i++) { for(int j = 0; j &lt; 3; j++) { Vector2 circleCenter = new Vector2(circleInterval * (i + 1), circleInterval * (j + 1)); float dist = Vector2.Distance(new Vector2(w, h), circleCenter) - radius; Color color = MixColor(circleColor, new Color(pixel.r, pixel.g, pixel.b, 0.0f), Mathf.SmoothStep(0f, 1.0f, dist * edgeBlur)); pixel = MixColor(pixel, color, color.a); } } pTex.SetPixel(w, h, pixel); } } pTex.Apply(); return pTex; } private Color MixColor(Color color0, Color color1, float mixFactor) { Color mixColor = Color.white; mixColor.r = Mathf.Lerp(color0.r, color1.r, mixFactor); mixColor.g = Mathf.Lerp(color0.g, color1.g, mixFactor); mixColor.b = Mathf.Lerp(color0.b, color1.b, mixFactor); mixColor.a = Mathf.Lerp(color0.a, color1.a, mixFactor); return mixColor; } 性能消耗以秒计…不实用。","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"玻璃透明效果","date":"2017-01-04T16:00:00.000Z","path":"2017/01/05/glassrefraction/","text":"用ComputeGrabScreenPos取得被抓取的屏幕的对应对标。 计算出切线空间到世界坐标的转换矩阵，存在3个float4中，剩下的一位存入worldPos。 用_Distortion和_RefractionTex_TexelSize来计算出一个偏移量来偏移屏幕采样坐标，模拟折射的效果。 用反射方向对Cubemap采样，得到反射颜色，反射颜色+折射颜色得到最后的输出颜色。 Shader &quot;UnityShaderLearning/GlassRefraction&quot; { Properties { _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; {} _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; {} _Cubemap (&quot;Environment Cubemap&quot;, Cube) = &quot;_Skybox&quot; {} _Distortion (&quot;Distortion&quot;, Range(0, 100)) = 10 _RefractAmount (&quot;Refract Amount&quot;, Range(0.0, 1.0)) = 1.0 } SubShader { Tags { &quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Opaque&quot; } GrabPass { &quot;_RefractionTex&quot; } Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;UnityCG.cginc&quot; sampler2D _MainTex; float4 _MainTex_ST; sampler2D _BumpMap; float4 _BumpMap_ST; samplerCUBE _Cubemap; float _Distortion; fixed _RefractAmount; sampler2D _RefractionTex; float4 _RefractionTex_TexelSize; struct a2v { float4 vertex : POSITION; float2 texcoord : TEXCOORD0; float3 normal : NORMAL; float4 tangent : TANGENT; }; struct v2f { float4 pos : SV_POSITION; float4 scrPos : TEXCOORD0; float4 uv : TEXCOORD1; float4 TtoW0 : TEXCOORD2; float4 TtoW1 : TEXCOORD3; float4 TtoW2 : TEXCOORD4; }; v2f vert (a2v v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.scrPos = ComputeGrabScreenPos(o.pos); o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex); o.uv.zw = TRANSFORM_TEX(v.texcoord, _BumpMap); float3 worldPos = mul(_Object2World, v.vertex).xyz; fixed3 worldNormal = UnityObjectToWorldNormal(v.normal); fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz); fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w; o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x); o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y); o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z); return o; } fixed4 frag(v2f i) : SV_Target { float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w); fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos)); fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw)); float2 offset = bump.xy * _Distortion * _RefractionTex_TexelSize.xy; i.scrPos.xy = offset + i.scrPos.xy; fixed3 RefrCol = tex2D(_RefractionTex, i.scrPos.xy/i.scrPos.w).rgb; bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump))); fixed3 reflDir = reflect(-worldViewDir, bump); fixed4 texColor = tex2D(_MainTex, i.uv.xy); fixed3 reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb; fixed3 finalColor = reflCol * (1 - _RefractAmount) + RefrCol * _RefractAmount; return fixed4(finalColor, 1); } ENDCG } } FallBack &quot;Diffuse&quot; }","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"镜子效果","date":"2016-12-27T16:43:00.000Z","path":"2016/12/28/mirror/","text":"一个简单的shader就能实现镜子的效果。在镜子的位置放一个相机，把相机的RenderTexture翻转，1 - uv.x。 Shader &quot;UnityShaderLearning/Mirror&quot; { Properties { _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; {} } SubShader { Tags { &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot; } Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag sampler2D _MainTex; struct a2v { float4 vertex : POSITION; float3 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float2 uv : TEXCOORD0; }; v2f vert(a2v v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.uv = v.texcoord; o.uv.x = 1 - o.uv.x; return o; } fixed4 frag(v2f i):SV_Target { return tex2D(_MainTex, i.uv); } ENDCG } } FallBack Off }","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"反射材质","date":"2016-12-21T18:01:00.000Z","path":"2016/12/22/reflection/","text":"这是使用了反射材质的水壶，模拟了金属反射室内的情况。室内用的是一个天空球模拟的。 fixed fresnel = _FresnelScale + (1 - _FresnelScale) * pow(1 - dot(worldViewDir, worldNormal), 5); 在片元着色器添加一行菲涅尔反射用的参数，然后将正常的ReflectionShader的_ReflectAmount换成新计算的fresnel，改变插值的系数。 Shader &quot;UnityShaderLearning/Reflection&quot; { Properties { _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1) _ReflectColor (&quot;Reflection Color&quot;, Color) = (1, 1, 1, 1) _ReflectAmount (&quot;Reflect Amount&quot;, Range(0, 1)) = 1 _Cubemap (&quot;Reflection Cubemap&quot;, Cube) = &quot;_Skybox&quot; {} } SubShader { Tags { &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot; } Pass { Tags { &quot;Lighting&quot;=&quot;ForwardBase&quot; } CGPROGRAM #pragma multi_compile_fwdbase #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; #include &quot;AutoLight.cginc&quot; fixed4 _Color; fixed4 _ReflectColor; fixed _ReflectAmount; samplerCUBE _Cubemap; struct a2v { float4 vertex : POSITION; float3 normal : NORMAL; }; struct v2f { float4 pos : SV_POSITION; fixed3 worldPos : TEXCOORD0; fixed3 worldNormal : TEXCOORD1; fixed3 worldViewDir : TEXCOORD2; fixed3 worldRefl : TEXCOORD3; SHADOW_COORDS(4) }; v2f vert(a2v v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(_Object2World, v.vertex).xyz; o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos); o.worldRefl = reflect(-o.worldViewDir, o.worldNormal); TRANSFER_SHADOW(o); return o; } fixed4 frag(v2f i) : SV_Target { fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); fixed3 worldViewDir = normalize(i.worldViewDir); fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(0, dot(worldNormal, worldLightDir)); fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb * _ReflectColor.rgb; UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos); fixed3 color = ambient + lerp(diffuse, reflection, _ReflectAmount) * atten; return fixed4(color, 1.0); } ENDCG } } FallBack &quot;Reflective/VertexLit&quot; }","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"实时阴影","date":"2016-12-15T02:42:00.000Z","path":"2016/12/15/shadow/","text":"1. Unity内部的ShadowCasterShaderPass { Name &quot;ShadowCaster&quot; Tags { &quot;LightMode&quot;=&quot;ShadowCaster&quot; } CGPROGRAM #pragma vertex vert #pragma fragment frag #pragma multi_compile_shadowcaster #include &quot;UnityCG.cginc&quot; struct v2f { V2F_SHADOW_CASTER; }; v2f vert(appdata_base v) { v2f o; TRANSFER_SHADOW_CASTER_NORMALOFFSET(o) return o; } float4 frag(v2f i) : SV_Target { SHADOW_CASTER_FRAGMENT(i) } ENDCG } 2. ShadowRecv 在ForwardRendering.shader中添加SHADOW_COORDS TRANSFER_SHADOW SHADOW_ATTENUATION即可变成ShadowRecv.shader Shader &quot;UnityShaderLearning/ShadowRecv&quot; { Properties { _Diffuse(&quot;Diffuse&quot;, Color) = (1, 1, 1, 1) _Specular(&quot;Specular&quot;, Color) = (1, 1, 1, 1) _Gloss(&quot;Gloss&quot;, Range(8.0, 256)) = 20 } SubShader { Pass { Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; } CGPROGRAM #pragma multi_compile_fwbase #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; #include &quot;AutoLight.cginc&quot; fixed4 _Diffuse; fixed4 _Specular; float _Gloss; struct a2v { float4 vertex : POSITION; float3 normal : NORMAL; }; struct v2f { float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; SHADOW_COORDS(2) }; v2f vert(a2v v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.worldNormal = normalize(mul(v.normal, (float3x3)_World2Object)); o.worldPos = mul(_Object2World, v.vertex).xyz; TRANSFER_SHADOW(o); return o; } fixed4 frag(v2f i) :SV_Target { fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir)); fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz); fixed3 halfDir = normalize(viewDir + worldLightDir); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(worldNormal, halfDir)), _Gloss); fixed atten = 1.0; fixed4 shadow = SHADOW_ATTENUATION(i); return fixed4(ambient + (diffuse + specular) * atten * shadow, 1.0); } ENDCG } Pass { Tags { &quot;LightMode&quot;=&quot;ForwardAdd&quot; } Blend SrcAlpha One CGPROGRAM #pragma multi_compile_fwbase #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; #include &quot;AutoLight.cginc&quot; fixed4 _Diffuse; fixed4 _Specular; float _Gloss; struct a2v { float4 vertex : POSITION; float3 normal : NORMAL; }; struct v2f { float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; }; v2f vert(a2v v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(_Object2World, v.vertex).xyz; return o; } fixed4 frag(v2f i) : SV_Target { fixed3 worldNormal = normalize(i.worldNormal); #ifdef USING_DIRECTIONAL_LIGHT fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); #else fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz - i.worldPos.xyz); #endif fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(0, dot(worldNormal, worldLightDir)); fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz); fixed3 halfDir = normalize(worldLightDir + viewDir); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss); #ifdef USING_DIRECTIONAL_LIGHT fixed atten = 1.0; #else #if defined (POINT) float3 lightCoord = mul(_LightMatrix0, float4(i.worldPos, 1)).xyz; fixed atten = tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL; #elif defined (SPOT) float4 lightCoord = mul(_LightMatrix0, float4(i.worldPos, 1)); fixed atten = (lightCoord.z &gt; 0) * tex2D(_LightTexture0, lightCoord.xy / lightCoord.w + 0.5).w * tex2D(_LightTextureB0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL; #else fixed atten = 1.0; #endif #endif return fixed4((diffuse + specular) * atten, 1.0); } ENDCG } } FallBack &quot;Specular&quot; } 3. 透明物体的阴影效果 Shader &quot;UnityShaderLearning/AlphaTestWithShadow&quot; { Properties { _Color (&quot;Main Tint&quot;, Color) = (1, 1, 1, 1) _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot;{} _Cutoff (&quot;Alpha Cutoff&quot;, Range(0, 1)) = 0.55 } SubShader { Tags { &quot;Queue&quot;=&quot;AlphaTest&quot; &quot;IgnoreProjector&quot; = &quot;True&quot; &quot;RenderType&quot;=&quot;TransparentCutout&quot;} Pass { Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; } Cull Off CGPROGRAM #pragma multi_compile_fwdbase #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; #include &quot;AutoLight.cginc&quot; fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; fixed _Cutoff; struct a2v { float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; float2 uv : TEXCOORD2; SHADOW_COORDS(3) }; v2f vert(a2v v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(_Object2World, v.vertex).xyz; o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); TRANSFER_SHADOW(o); return o; } fixed4 frag(v2f i) : SV_Target { fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); fixed4 texColor = tex2D(_MainTex, i.uv); clip (texColor.a - _Cutoff); fixed3 albedo = texColor.rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir)); UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos); return fixed4(ambient + diffuse * atten, 1.0); } ENDCG } } FallBack &quot;VertexLit&quot; }","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"Lua OO 实现 ","date":"2016-12-09T13:49:00.000Z","path":"2016/12/09/luaoo/","text":"Lua OO 实现##1. 类的实现12345678910111213141516171819testClass =&#123; id, num&#125;;testClass.__index = testClassfunction testClass:new(id, num) local self = &#123;&#125; setmetatable(self, testClass) self.id = id self.num = num return selfendfunction testClass:PrintNum() print(\"num is \" .. self.num)end 简单使用12local obj = testClass:new(10, 11)obj:PrintNum() 得到输出num is 11 ##2. 类的继承Class A123456789101112131415161718A = &#123;&#125;function A:new(o) o = o or &#123;&#125; //self指向o setmetatable(o, self) //__index设为A self.__index = self return o;endfunction A:PrintClassName() print(\"this is class A\")endfunction A:AMethod() print(\"this is AMethod !\")end Class B继承Class A12345B = A:new()function B:PrintClassName() print(\"this is class B !\")end 使用示例123local obj = B:new()obj:PrintClassName()obj:AMethod() 输出 this is class B ! this is AMethod !","tags":[{"name":"Lua","slug":"Lua","permalink":"blog.codershu.com/tags/Lua/"}]},{"title":"Unity和Java交互","date":"2016-12-07T20:42:00.000Z","path":"2016/12/08/CSharpAndJava/","text":"#CSharpToJava ##1. new Java类12345678910static AndroidJavaClass _UnityPlayer;static AndroidJavaClass unityPlayer&#123; get &#123; if (_UnityPlayer == null) _UnityPlayer = new AndroidJavaClass(\"com.unity3d.player.UnityPlayer\"); return _UnityPlayer; &#125;&#125; ##2. 调用Java函数 调用无参无返回函数 12//调用静态函数为CallStaticandroidJavaClass.Call(\"methodName\"); 调用带参数有返回函数 1234567891011121314//返回值为int则为Call&lt;int&gt;//返回值为Java自定义的数据类型, 比如Java类。则为CallStatic&lt;AndroidJavaObject&gt;//调用静态函数为CallStaticString str = androidJavaClass.Call&lt;String&gt;(\"methodName\", param1, param2);``` &lt;!-- more --&gt;##3. 访问Java类的属性- 访问普通属性``` //访问int属性则为Get&lt;int&gt;String str = androidJavaClass.Get&lt;String&gt;(\"PropertyName\")``` - 访问静态属性 //示例如下:unityPlayer.GetStatic(“currentActivity”)1234#JavaToCSharp ## 1. Java调用CSharp**需要在场景中创建一个名为AScript的GameObject** //调用场景中的GameObject:AScript挂载的脚本AScript中的BMethod，传入参数param。UnityPlayer.UnitySendMessage(“AScript”,”BMethod”, param);```","tags":[{"name":"Unity - Java - C#","slug":"Unity-Java-C","permalink":"blog.codershu.com/tags/Unity-Java-C/"}]},{"title":"遮罩纹理","date":"2016-12-07T15:55:00.000Z","path":"2016/12/07/masktexture/","text":"左图使用了遮罩纹理，右侧是普通的Blin-Phone模型，在高光上表现得更加细腻。 上图是使用了主纹理/法线贴图/遮罩纹理的效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283Shader \"UnityShaderLearning/MaskTexture\" &#123; Properties &#123; _Color (\"Color Tint\", Color) = (1, 1, 1, 1) _MainTex (\"Main Tex\", 2D) = \"white\"&#123;&#125; _BumpMap (\"Nomral Map\", 2D) = \"bump\"&#123;&#125; _BumpScale(\"Bump Scale\", Float) = 1.0 _SpecularMask (\"Specular Mask\", 2D) = \"white\"&#123;&#125; _SpecularScale (\"Specular Scale\", Float) = 1.0 _Specular (\"Specular\", Color) = (1, 1, 1, 1) _Gloss (\"Gloss\", Range(8.0, 256)) = 20 &#125; SubShader &#123; Pass &#123; Tags &#123; \"LightMode\"=\"ForwardBase\" &#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"Lighting.cginc\" fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; sampler2D _BumpMap; float _BumpScale; sampler2D _SpecularMask; float _SpecularScale; fixed4 _Specular; float _Gloss; struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; float4 texcoord : TEXCOORD0; &#125;; struct v2f &#123; float4 pos : SV_POSITION; float2 uv : TEXCOORD0; float3 lightDir : TEXCOORD1; float3 viewDir : TEXCOORD2; &#125;; v2f vert(a2v v) &#123; v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.uv.xy = v.texcoord.xy * _MainTex_ST.xy * _MainTex_ST.zw; TANGENT_SPACE_ROTATION; o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz; o.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz; return o; &#125; fixed4 frag(v2f i) : SV_Target &#123; fixed3 tangentLightDir = normalize(i.lightDir); fixed3 tangentViewDir = normalize(i.viewDir); fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uv)); tangentNormal.xy *= _BumpScale; tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy))); fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(tangentNormal, tangentLightDir)); fixed3 halfDir = normalize(tangentLightDir + tangentViewDir); fixed specularMask = tex2D(_SpecularMask, i.uv).r * _SpecularScale; fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(tangentNormal, halfDir)), _Gloss) * specularMask; return fixed4(ambient + diffuse + specular, 1.0); &#125; ENDCG &#125; &#125; FallBack \"Diffuse\"&#125;","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"渐变纹理","date":"2016-12-06T17:07:00.000Z","path":"2016/12/07/ramptexture/","text":"12fixed halfLambert = 0.5 * dot(worldNormal, worldLightDir) + 0.5;fixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert, halfLambert)).rgb * _Color.rgb; 关键代码有两行 第一行代码获得了法线和光线方向的夹角的余弦值*0.5 + 0.5, 即把余弦值映射到[0, 1]。 第二行代码在渐变纹理上采样 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Shader \"UnityShaderLearning/RampTexture\" &#123; Properties &#123; _Color (\"Color Tint\", Color) = (1,1,1,1) _RampTex (\"Ramp Tex\", 2D) = \"white\" &#123;&#125; _Specular (\"Specular\", Color) = (1, 1, 1, 1) _Gloss (\"Gloss\", Range(8.0, 256)) = 20 &#125; SubShader &#123; Pass &#123; Tags &#123; \"LightMode\"=\"ForwardBase\" &#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"Lighting.cginc\" fixed4 _Color; sampler2D _RampTex; float4 _RampTex_ST; fixed4 _Specular; float _Gloss; struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord : TEXCOORD0; &#125;; struct v2f &#123; float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; float2 uv : TEXCOORD2; &#125;; v2f vert(a2v v) &#123; v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(_Object2World, v.vertex).xyz; o.uv = TRANSFORM_TEX(v.texcoord, _RampTex); return o; &#125; fixed4 frag(v2f i) : SV_Target &#123; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed halfLambert = 0.5 * dot(worldNormal, worldLightDir) + 0.5; fixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert, halfLambert)).rgb * _Color.rgb; fixed3 diffuse = _LightColor0.rgb * diffuseColor; fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos)); fixed3 halfDir = normalize(worldLightDir + viewDir); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss); return fixed4(ambient + diffuse + specular, 1.0); &#125; ENDCG &#125; &#125; FallBack \"Diffuse\"&#125;","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"切线空间下的法线贴图应用","date":"2016-12-06T16:26:00.000Z","path":"2016/12/07/normalmaptangentspace/","text":"左侧BumpScale为-1 右侧BumpScale为1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889Shader \"UnityShaderLearning/NormalMapTangentSpace\"&#123; Properties &#123; _Color(\"Color Tint\", Color) = (1, 1, 1, 1) _MainTex(\"Main Tex\", 2D) = \"white\"&#123;&#125; _BumpMap(\"Normal Map\", 2D) = \"bump\"&#123;&#125; _BumpScale(\"Bump Scale\", Float) = 1.0 _Specular(\"Specular\", Color) = (1, 1, 1, 1) _Gloss(\"Gloss\", Range(8.0, 256)) = 20 &#125; SubShader &#123; Pass &#123; Tags &#123; \"LightMode\"=\"ForwardBase\" &#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"Lighting.cginc\" fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; sampler2D _BumpMap; float4 _BumpMap_ST; float _BumpScale; fixed4 _Specular; float _Gloss; struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; float4 texcoord : TEXCOORD0; &#125;; struct v2f &#123; float4 pos : SV_POSITION; float4 uv : TEXCOORD0; float3 LightDir : TEXCOORD1; float3 ViewDir : TEXCOORD2; &#125;; v2f vert(a2v v) &#123; v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.uv.xy = v.vertex.xy * _MainTex_ST.xy + _MainTex_ST.zw; o.uv.zw = v.vertex.xy * _BumpMap_ST.xy + _BumpMap_ST.zw; float3 binormal = cross(normalize(v.normal), normalize(v.tangent.xyz)); float3x3 rotation = float3x3(v.tangent.xyz, binormal, v.normal); o.LightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz; o.ViewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz; return o; &#125; fixed4 frag(v2f i) : SV_Target &#123; fixed3 tangentLightDir = normalize(i.LightDir); fixed3 tangentViewDir = normalize(i.ViewDir); fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw); fixed3 tangentNormal; // tangentNormal.xy = (packedNormal.xy * 2 - 1) * _BumpScale; // tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy))); tangentNormal = UnpackNormal(packedNormal); tangentNormal.xy *= _BumpScale; tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy))); fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(tangentNormal, tangentLightDir)); fixed3 halfDir = normalize(tangentViewDir + tangentLightDir); fixed3 specular = _LightColor0 * _Specular.rgb * pow(max(0, dot(tangentNormal, halfDir)), _Gloss); return fixed4(ambient + diffuse + specular, 1.0); &#125; ENDCG &#125; &#125; FallBack \"specular\"&#125;","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"逐顶点和逐像素的高光模型","date":"2016-11-18T17:26:00.000Z","path":"2016/11/19/specularvertexlevelpixellevel/","text":"左为逐顶点高光Phong模型 中为逐像素高光Phong模型 右为逐像素高光Blinn-Phong模型 Phong模型$$C{specular=(c{light}*m{specular})max(0, \\vec{v}·\\vec{r})^{m{Gloss}}}$$ Blinn-Phong模型$$C{specular=(c{light}*m{specular})max(0, \\vec{n}·\\vec{h})^{m{Gloss}}}$$ $$\\vec{h} = \\frac{\\vec{v}·\\vec{i}}{|v||i|}$$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Shader &quot;UnityShaderLearning/SpecularVertexLevel&quot;&#123; Properties &#123; _Diffuse(&quot;Diffuse&quot;, Color) = (1, 1, 1, 1) _Specular(&quot;Specular&quot;, Color) = (1, 1, 1, 1) _Gloss(&quot;Gloss&quot;, Range(8.0, 256)) = 20 &#125; SubShader &#123; Pass &#123; Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; fixed4 _Diffuse; fixed4 _Specular; float _Gloss; struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; &#125;; struct v2f &#123; float4 pos : SV_POSITION; float3 color : COLOR; &#125;; v2f vert(a2v v) &#123; v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 worldNormal = normalize(mul(v.normal, (float3x3)_World2Object)); fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir)); fixed3 reflectDir = normalize(reflect(-worldLightDir, worldNormal)); fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - mul(_Object2World, v.vertex).xyz); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(reflectDir, viewDir)), _Gloss); o.color = ambient + diffuse + specular; return o; &#125; fixed4 frag(v2f i) :SV_Target &#123; return fixed4(i.color, 1.0); &#125; ENDCG &#125; &#125; FallBack &quot;Specular&quot;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Shader \"UnityShaderLearning/SpecularPixelLevel\"&#123; Properties &#123; _Diffuse(\"Diffuse\", Color) = (1, 1, 1, 1) _Specular(\"Specular\", Color) = (1, 1, 1, 1) _Gloss(\"Gloss\", Range(8.0, 256)) = 20 &#125; SubShader &#123; Pass &#123; Tags &#123; \"LightMode\"=\"ForwardBase\" &#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"Lighting.cginc\" fixed4 _Diffuse; fixed4 _Specular; float _Gloss; struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; &#125;; struct v2f &#123; float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; &#125;; v2f vert(a2v v) &#123; v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.worldNormal = normalize(mul(v.normal, (float3x3)_World2Object)); o.worldPos = mul(_Object2World, v.vertex).xyz; return o; &#125; fixed4 frag(v2f i) :SV_Target &#123; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir)); fixed3 reflectDir = normalize(reflect(-worldLightDir, worldNormal)); fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(reflectDir, viewDir)), _Gloss); fixed3 color = ambient + diffuse + specular; return fixed4(color, 1.0); &#125; ENDCG &#125; &#125; FallBack \"Specular\"&#125;``` ``` fixed3 halfDir = normalize(viewDir + worldLightDir);fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(worldNormal, halfDir)), _Gloss);","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"DiffuseVertexLevel/PixelLevel(漫反射)","date":"2016-11-17T16:24:00.000Z","path":"2016/11/18/diffuseshadervertexlevel/","text":"左为逐顶点漫反射光照模型，右为逐像素漫反射光照模型。 漫反射光照模型$$C{diffuse}=(C{light} * m_{diffuse})max(0, \\vec{n}·\\vec{i})$$ $$C_{light}$$入射光颜色和强度 $$m_{diffuse}$$材质漫反射系数 $$\\vec{n}$$法线方向 $$\\vec{i}$$光源方向 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Shader \"UnityShaderLearning/DiffuseVertexLevel\"&#123; Properties &#123; _Diffuse(\"Diffuse\", Color) = (1, 1, 1, 1) &#125; SubShader &#123; Pass &#123; Tags&#123; \"LightMode\"=\"ForwardBase\" &#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"Lighting.cginc\" fixed4 _Diffuse; struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; &#125;; struct v2f &#123; float4 pos : SV_POSITION; fixed3 color : COLOR; &#125;; v2f vert(a2v v) &#123; v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 worldNormal = normalize(mul(v.normal, (float3x3)_World2Object)); fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz); fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLight)); o.color = ambient + diffuse; return o; &#125; fixed4 frag(v2f i) : SV_Target &#123; return fixed4(i.color, 1.0); &#125; ENDCG &#125; &#125; FallBack \"Diffuse\"&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Shader \"UnityShaderLearning/DiffusePixelLevel\"&#123; Properties &#123; _Diffuse(\"Diffuse\", Color) = (1, 1, 1, 1) &#125; SubShader &#123; Pass &#123; Tags&#123; \"LightMode\" = \"ForwardBase\" &#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"Lighting.cginc\" fixed4 _Diffuse; struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; &#125;; struct v2f &#123; float4 pos : SV_POSITION; fixed3 worldNormal : TEXCOORD0; &#125;; v2f vert(a2v v) &#123; v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.worldNormal =mul(v.normal, (float3x3)_World2Object); return o; &#125; fixed4 frag(v2f i) : SV_Target &#123; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir)); fixed3 color = ambient + diffuse; return fixed4(color, 1.0); &#125; ENDCG &#125; &#125; FallBack \"Diffuse\"&#125;","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"AssetBundle冗余检测器","date":"2016-11-10T16:00:00.000Z","path":"2016/11/11/assetbundleRedencyCheck/","text":"最近我们项目快上线了，把项目提交到了一个专业做Unity项目优化的网站。——uwa 他们号称没有不存在资源冗余的项目，我们提交以后确实发现了一些冗余资源。但是他们网站有2个缺陷： 免费用户一个月只能检测2次 不自由 付费用户6600/季度 需要上传自己项目的所有AB文件 不安全 而且，我仔细想了下，这里面的技术其实不是很复杂。就衍生了一个自己写一个小插件的想法，然后ABRedundancyChecker就诞生了。 一、插件介绍 我把AB包所有的资源分为两类 本包资源 依赖包资源 该插件把每个AB包的本包资源都列举出来，然后统计这些资源是否有重复，重复则为冗余。 插件github仓库地址：https://github.com/inkiu0/ABRedundancyChecker 喜欢的赏颗星星 二、ABRedundancyChecker使用方法1. 修改脚本参数 把以下参数改成自己想要的: 1234567891011121314151617181920212223242526272829303132333435/// &lt;summary&gt;/// AB文件名匹配规则/// &lt;/summary&gt;public string searchPattern = \"*.ab\";/// &lt;summary&gt;/// 冗余资源类型白名单/// &lt;/summary&gt;public List&lt;Type&gt; assetTypeList = new List&lt;Type&gt; &#123; typeof(Material), typeof(Texture2D), typeof(AnimationClip),typeof(AudioClip), typeof(Sprite), typeof(Shader), typeof(Font), typeof(Mesh) &#125;;/// &lt;summary&gt;/// 输出路径/// &lt;/summary&gt;public string outPath = Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory);/// &lt;summary&gt;/// AB文件存放路径，会从这个文件夹下递归查找符合查找规则searchPattern的文件。/// &lt;/summary&gt;public string abPath = \"Assets/StreamingAssets\";[MenuItem(\"AB冗余检测/AB检测\")] 2. 开始使用 将ABRedundancyChecker.cs放在Unity项目的Editor目录下 将所有打包好的AssetBundle文件放在abPath目录下 点击菜单栏AB冗余检测-&gt;AB检测 喝一杯茶 250MB的AB文件(1600个文件)检测时间为2分钟 打开输出到目标目录的MarkDown文件 3. 输出的MarkDown形如","tags":[{"name":"Unity","slug":"Unity","permalink":"blog.codershu.com/tags/Unity/"}]},{"title":"Alpha分离","date":"2016-10-30T16:00:00.000Z","path":"2016/10/31/separateAlpha/","text":"1. 为什么要进行Alpha分离？ 使得图集可以压缩，减小包量。 2. Alpha分离要点1. 分离 收集图集 123456List&lt;Texture2D&gt; m_AtlasList = new List&lt;Texture2D&gt;();private void CollectAtlasSprite()&#123; //Travel all AtlasSprite m_AtlasList.Add(obj as Texture2D);&#125; 分离单张图集的Alpha 123456789101112131415161718192021222324252627282930public static void separateOneTexture(Texture2D sourceTex)&#123; string sourceTexPath= AssetDatabase.GetAssetPath(sourceTex); //创建2张RGB格式的纹理，最后保存的时候会把rgba的alpha丢弃掉。 Texture2D texRGB = new Texture2D(sourceTex.width, sourceTex.height, TextureFormat.RGB24, false); Texture2D texAlpha = new Texture2D(sourceTex.width, sourceTex.height, TextureFormat.RGB24, false); //取得原始像素数据 Color[] srcColors = sourceTex.GetPixels(); texRGB.SetPixels(srcColors); //生成 rgba = (a, a, a, a) 的图片 Color[] alphaColors = new Color[srcColors.Length]; for(int i=0;i&lt;srcColors.Length;i++) &#123; alphaColors[i].r = srcColors[i].a; alphaColors[i].g = srcColors[i].a; alphaColors[i].b = srcColors[i].a; &#125; texAlpha.SetPixels(alphaColors); texRGB.Apply(); texAlpha.Apply(); byte[] rgbBytes = texRGB.EncodeToPNG(); File.WriteAllBytes(sourceTexPath, rgbBytes); byte[] alphaBytes = texAlpha.EncodeToPNG(); File.WriteAllBytes(alphaTexPath, alphaBytes);&#125; 记得检查图片的AssetImporter.GetAtPath(sourceTexFullPath).isReadable == true，否则不能进行SetPixels和GetPixels操作 2. 合并 合并Alpha图片和RGB图片 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void mergeTwoTexture(Texture2D t2dRGB,Texture2D t2dAlpha)&#123; string strRGBPath = AssetDatabase.GetAssetPath(t2dRGB); string strAlphaPath = AssetDatabase.GetAssetPath(t2dAlpha); TextureImporter importerRGBTex = AssetImporter.GetAtPath(strRGBPath) as TextureImporter; if (!importerRGBTex.isReadable) &#123; //检查isReadable属性 importerRGBTex.isReadable = true; AssetDatabase.ImportAsset(strRGBPath); &#125; TextureImporter importerAlphaTex = AssetImporter.GetAtPath(strAlphaPath) as TextureImporter; if(!importerAlphaTex.isReadable) &#123; //检查isReadable属性 importerAlphaTex.isReadable = true; AssetDatabase.ImportAsset(strAlphaPath); &#125; Color[] rgbDatas = t2dRGB.GetPixels(); Color[] alphaDatas = t2dAlpha.GetPixels(); Color[] rgbaDatas = new Color[rgbDatas.Length]; Texture2D texRGBA = new Texture2D(t2dRGB.width, t2dRGB.height, TextureFormat.RGBA32,false); for(int nI=0;nI&lt;rgbaDatas.Length;nI++) &#123; rgbaDatas[nI].r = rgbDatas[nI].r; rgbaDatas[nI].g = rgbDatas[nI].g; rgbaDatas[nI].b = rgbDatas[nI].b; rgbaDatas[nI].a = alphaDatas[nI].r; &#125; texRGBA.SetPixels(rgbaDatas); texRGBA.Apply(); byte[] rgbaBytes = texRGBA.EncodeToPNG(); File.WriteAllBytes(strRGBPath, rgbaBytes); AssetDatabase.DeleteAsset(strAlphaPath); AssetDatabase.Refresh(); ReImportAsset(strRGBPath); &#125;","tags":[{"name":"Unity","slug":"Unity","permalink":"blog.codershu.com/tags/Unity/"}]},{"title":"Xcode8自动打包去掉AutoMaticallyManageSigning","date":"2016-10-30T16:00:00.000Z","path":"2016/10/31/xcode8automaticallymanag/","text":"最近项目里的自动打包脚本不能用了，一直提示123456789Check dependenciesSigning for \"Unity-iPhone\" requires a development team. Select a development team in the project editor.Code signing is required for product type 'Application' in SDK 'iOS 10.0'** BUILD FAILED **The following build commands failed: Check dependencies(1 failure) Google了一下发现是xcode新的自动管理签名机制的问题，你要不使用AutoMatic自动管理，要不使用Manual手动指定证书的模式。 无奈我们打包的时候只有证书，没有对应的AppleID，所以自动管理的就用不了。但是UnityBuild出来的Xcode项目是自动勾选Auto MaticallyManageSigning的，而且Xcode也没有支持用命令行设置这个值。那这样的话，我们每次打包出Xcode项目的时候需要手动点一下，这就失去打包工具的意义了。 无奈之下，找到一个办法解决这个问题。我先用UnityBuild出一个干净的Xcode项目，然后把项目传到Git。然后手动点一下BuildSetting里的Auto MaticallyManageSigning，去掉勾选。然后查看下diff，当然其中有很多修改。主要修改在Unity-iPhone.xcodeproj\\/project.pbxproj，在Finder里想打开该文件应选中Unity-iPhone.xcodeproj右键显示包内容。 project.pbxproj内也有很多修改，重要的修改其实只有几行，主要是在这个地方加上ProvisioningStyle = Manual。 修改前： 12345TargetAttributes = &#123; 5623C57217FDCB0800090B9E /* Unity-iPhone Tests */ = &#123; TestTargetID = 1D6058900D05DD3D006BFB54 /* Unity-iPhone */; &#125;;&#125;; 修改后： 12345678TargetAttributes = &#123; 5623C57217FDCB0800090B9E /* Unity-iPhone Tests */ = &#123; TestTargetID = 1D6058900D05DD3D006BFB54 /* Unity-iPhone */; &#125;; 1D6058900D05DD3D006BFB54 = &#123; ProvisioningStyle = Manual; &#125;;&#125;; 需要注意的是从来没有用Xcode打开并且操作过的project.pbxproj是不存在ProvisioningStyle字段的，所以应追加3行。但是打开并操作过的项目是存在ProvisioningStyle字段的，这个时候如果想用脚本修改该值应直接替换该值1sed -i \"\" s/'ProvisioningStyle = Automatic;'/'DevelopmentTeam = None;ProvisioningStyle = Manual;'/g project.pbxprojPath 因为我们是全自动的打包过程，正常流程是不用打开xcode项目的，所以我准备用sed在指定文本下追加3行，并且要获取上一次匹配到的TestTargetID，我写到3点还没写出来……实在不会。所以我用python实现了这个操作，附上python脚本DelMatically.py。1234567891011121314#!/usr/bin/pythonimport osimport reprint 'start python script! Delete AutoMatically Manage Signing'filePath = \"/Users/yons/Documents/work/bin/prj/Unity-iPhone.xcodeproj/project.pbxproj\"f = open(filePath, 'r+')contents = f.read()f.seek(0)f.truncate()pattern = re.compile(r'(TestTargetID = (\\w*)) \\/\\* Unity-iPhone \\*\\/;')f.write(pattern.sub(r'\\1;\\n\\t\\t\\t\\t\\t&#125;;\\n\\t\\t\\t\\t\\t\\2 = &#123;\\n\\t\\t\\t\\t\\t\\tProvisioningStyle = Manual;', contents))f.close()print 'end python script !' 然后用shell运行python，把xcodeprojPath和Yours换成你们自己对应的值。12python DelAutoMatically.pyxcodebuild -project xcodeprojPath -sdk iphoneos -scheme \"Unity-iPhone\" CONFIGURATION_BUILD_DIR='./' CODE_SIGN_IDENTITY=\"Yours\" PROVISIONING_PROFILE=\"Yours\" 需要注意的是PROVISIONING_PROFILE值应该是一串数字+字母，这个值可以用NodePad++打开对应的mobileprovision文件，其中有如下结构。其中string标签包裹的值即是PROVISIONING_PROFILE。 12&lt;key&gt;UUID&lt;/key&gt;&lt;string&gt;&lt;/string&gt;","tags":[{"name":"Xcode打包","slug":"Xcode打包","permalink":"blog.codershu.com/tags/Xcode打包/"}]},{"title":"AVL树和红黑树 ","date":"2016-10-30T16:00:00.000Z","path":"2016/10/31/RBTree/","text":"技术分享会旨在：抛砖引玉，促进程序之间互相交流，培养公司内部良好的技术氛围。 1. Base此次分享会默认大家清楚了解以下知识点： 二叉查找树(binary search tree)的定义和实现 AVL树的定义和实现 基础的C/C++知识 此次分享会主要和大家分享探讨以下内容 AVL树和红黑树的异同 树的旋转 红黑树的在STL中的应用(SGI STL) 红黑树在跳跃表中的应用 2. AVL树和红黑树的性质###AVL树 高度为h的AVL树最少有S(h) = S(h-1) + S(h-2) + 1个节点 $$S(h) = \\frac{1}{\\sqrt{5}}((\\frac{1+\\sqrt{5}}{2})^{h+2} - (\\frac{1-\\sqrt{5}}{2})^{h+2}) - 1$$ $$\\because \\frac{(\\frac{1-\\sqrt{5}}{2})^{h+2}}{\\sqrt(5)} &lt; 1 \\therefore S(h) &gt; \\frac{(\\frac{1+\\sqrt{5}}{2})^{h+2}}{\\sqrt(5)} - 1$$ AVL树的高度不超过$$\\frac{3}{2}log_2^N$$ 查找时间复杂度: $$O(log_2^N)$$ 插入时间复杂度: $$O(log_2^N)$$+0-2次旋转 删除时间复杂度: $$O(log_2^N)$$+若干次旋转 删除操作最多会造成$$O(log_2^N)$$次旋转，这种情况发生在删除最简AVL树的一个节点时发生。 ###红黑树 红黑树的高度不超过$$2log_2^N$$ 查找时间复杂度: $$O(log_2^N)$$ 插入时间复杂度: $$O(log_2^N)$$+0-2次旋转 删除时间复杂度: $$O(log_2^N)$$+0-3次旋转 所有的AVL树都能不经旋转涂成红黑树，反之不行。 ###红黑树和AVL树对比结论：红黑树和AVL树时间复杂度是一样的，但是红黑树的统计性能更高！ 以下是对它们处理百万随机数的性能统计 ##3. 红黑树的插入和删除 插入我参考的是SGI STL版本的红黑数实现，源码如下： __rb_tree_rebalance(__rb_tree_node_base* x, __rb_tree_node_base*&amp; root) { //参数1为新增节点 x-&gt;color == __rb_tree_red; //新增节点必须为红色 while(x != root &amp;&amp; x-&gt;parent-&gt;color == __rb__tree_red) { if(x-&gt;parent == x-&gt;parent-&gt;parent-&gt;left) { //父节点为组父节点的左节点 __rb_tree_node_base* y = x-&gt;parent-&gt;parent-&gt;right; //令y为伯父节点 if(y &amp;&amp; y-&gt;color == __rb_tree_red) { //情况1 //伯父节点存在并且为红色 x-&gt;parent-&gt;color = __rb_tree_black; y-&gt;color = __rb_tree_black; x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red; x = x-&gt;parent-&gt;parent; //上滤 } else { //无伯父节点，或伯父节点为黑 if(x == x-&gt;parent-&gt;right) { //情况2 x = x-&gt;parent; __rb_tree_rotate_left(x, root); } //情况3 x-&gt;parent-&gt;color = __rb_tree_black; x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red; __rb_tree_rotate_right(x-&gt;parent-&gt;parent, root); } } else { __rb_tree_node_base* y = x-&gt;parent-&gt;parent-&gt;left; //令y为伯父节点 if(y &amp;&amp; y-&gt;color == __rb_tree_red) { //情况4 //伯父节点存在并且为红色 x-&gt;parent-&gt;color = __rb_tree_black; y-&gt;color = __rb_tree_black; y-&gt;parent-&gt;parent-&gt;color = __rb_tree_red; x = x-&gt;parent-&gt;parent; //上滤 } else { //无伯父节点，或伯父节点为黑 if(x == x-&gt;parent-&gt;left) { //情况5 x = x-&gt;parent; __rb_tree_rotate_right(x, root); } //情况6 x-&gt;parent-&gt;color = __rb_tree_black; x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red; __rb_tree_left(x-&gt;parent-&gt;parent, root); } } } root-&gt;color = __rb_tree_black; } ####左旋转动画 ####右旋转动画 ####情况1 直接把父节点和伯父节点改成黑色，祖父节点改成红色，继续上滤就可以了。 ####情况2 把子节点丰富 先对XP做一次左旋转 再对GX做一次右旋转并改变GX的颜色，SGI STL中提前改变了颜色，这是为了代码统一，不影响逻辑。 ####情况3 ####情况4 其实这种情况和情况1是相同的。 ####情况5 做一次左旋转 ####情况6 做一次右左双旋转 升序插入红黑树 降序插入红黑树 随机插入红黑树 ###删除 删除红色节点删除红色节点不影响红黑树的性质，可直接删除！ 删除黑色节点将右子节点的最左端节点代替该节点，然后进行reBlance。如果后继节点为红色，则直接改成黑色，不需要reBlance。经过节点A的所有路径长度都减少了1，reBlance过程中把这些情况分为以下4种。 节点A为删除后的替代节点，节点W为节点A的兄弟节点。 if (y-&gt;color != __rb_tree_red) { while (x != root &amp;&amp; (x == 0 || x-&gt;color == __rb_tree_black)) if (x == x_parent-&gt;left) { __rb_tree_node_base* w = x_parent-&gt;right; //情况1 if (w-&gt;color == __rb_tree_red) { w-&gt;color = __rb_tree_black; x_parent-&gt;color = __rb_tree_red; __rb_tree_rotate_left(x_parent, root); w = x_parent-&gt;right; } //情况2 if ((w-&gt;left == 0 || w-&gt;left-&gt;color == __rb_tree_black) &amp;&amp; (w-&gt;right == 0 || w-&gt;right-&gt;color == __rb_tree_black)) { w-&gt;color = __rb_tree_red; x = x_parent; x_parent = x_parent-&gt;parent; } else { //情况3 if (w-&gt;right == 0 || w-&gt;right-&gt;color == __rb_tree_black) { if (w-&gt;left) w-&gt;left-&gt;color = __rb_tree_black; w-&gt;color = __rb_tree_red; __rb_tree_rotate_right(w, root); w = x_parent-&gt;right; } //情况4 w-&gt;color = x_parent-&gt;color; x_parent-&gt;color = __rb_tree_black; if (w-&gt;right) w-&gt;right-&gt;color = __rb_tree_black; __rb_tree_rotate_left(x_parent, root); break; } } if (x) x-&gt;color = __rb_tree_black; } ####情况1W为红色，AW的父节点为黑色。对BD进行一次左旋，使得情况1转换成情况234中的一种。 ####情况2W和它两个子节点都为黑色把W涂成红色，使得A和W两个子树路径长度都-1。如果new x即B节点为红色，那么涂成黑色，就平衡了B节点的路径长。否则就需要上滤，继续平衡new x和其兄弟节点。 ####情况3W为黑色，W的左节点为红色，右节点为黑色。对WC进行一次右旋，转换为情况4 ####情况4W为黑色，右子节点为红色。对BD进行左旋，并交换颜色，再把W的右节点置为黑色。 查找while(x != 0) if(!key_compare(key(x), k)) //x键值大于k y = x, x = left(x); else x = right(x); iterator j = iterator(y); //k的值比树中最大值都大，或者没有找到，则返回end()。 //例如在root=10 10-&gt;left=8 10-&gt;right=14 14-&gt;left=11中查找12 return (j == end() || key_compare(k, key(j.node())) ? end() : j;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"blog.codershu.com/tags/数据结构与算法/"}]}]
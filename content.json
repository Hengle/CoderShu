[{"title":"Lua性能分析器的实现","date":"2017-02-21T15:44:00.000Z","path":"2017/02/21/luaprofiler/","text":"这个Profiler主要由3部分组成： 重写luaC库钩子函数的C类 lua类在钩子的回调中采集信息，并生成报表供C#使用。 C#类每帧取得数据存下来，并每0.5s取最新一帧显示在编辑器中。编辑器窗口完成一些自有功能。 lua第三方C库的编写想要编写一个第三方的luaC库，主要需要以下几点知识： lua栈的概念 lua栈的常用操作 其他常用的lua C API lua栈的概念","tags":[{"name":"Unity","slug":"Unity","permalink":"blog.codershu.com/tags/Unity/"},{"name":"Lua","slug":"Lua","permalink":"blog.codershu.com/tags/Lua/"}]},{"title":"Slua的优化初探","date":"2017-02-05T15:27:00.000Z","path":"2017/02/05/sluaunitytransform.position/","text":"看了UWA的blog以后，了解到了tolua对c#对象取值赋值的过程。并且发现slua对比tolua在test1里性能是tolua的6倍，所以很好奇slua做了哪些优化。 tolua取值赋值的过程 slua的取值赋值过程 取出object的缓存 ObjectCache oc = ObjectCache.get(l); 取得c#中的index然后再ObjectCache里面查找 cache.get(index, out o)，类似tolua中的Translator，都是从缓存中取出object int index = LuaDLL.luaS_rawnetobj(l, p); object o; if (index != -1 &amp;&amp; cache.get(index, out o)) { return o; } 从栈中取出3个float组成Vector3 UnityEngine.Vector3 v; checkType(l,2,out v); static public bool checkType(IntPtr l, int p, out Vector3 v) { float x, y, z; if(LuaDLL.luaS_checkVector3(l, p, out x, out y, out z)!=0) throw new Exception(string.Format(&quot;Invalid vector3 argument at {0}&quot;, p)); v = new Vector3(x, y, z); return true; } 赋值给position self.position=v; slua相比tolua做了哪些优化 赋值是在c#中完成的而不是取得object后把index构造成userdata后在lua中赋值 返回的object缓存起来了，没有频繁地GC 还有那些优化的余地 lua给c#传递3个float而不是一个内容为{x,y,z}的table","tags":[{"name":"Unity","slug":"Unity","permalink":"blog.codershu.com/tags/Unity/"},{"name":"Lua","slug":"Lua","permalink":"blog.codershu.com/tags/Lua/"},{"name":"Slua","slug":"Slua","permalink":"blog.codershu.com/tags/Slua/"}]},{"title":"运动模糊 ","date":"2017-01-25T16:00:00.000Z","path":"2017/01/26/MotionBlur/","text":"#MotionBlur运动模糊 首先为accumulationTexture进行一个恢复操作，以取得上一步混合得到的纹理。 然后用shader把原图像和上一步的纹理进行混合 最后把混合后的纹理显示在屏幕上。 accumulationTexture.MarkRestoreExpected(); material.SetFloat(&quot;_BlurAmount&quot;, 1.0f - blurAmount); Graphics.Blit(src, accumulationTexture, material); Graphics.Blit(accumulationTexture, dest); shader混合图像的方式为(last.rgb BlurAmount + src.rgb (1 - blurAmount), last.a) Shader &quot;UnityShaderLearning/MotionBlur&quot; { Properties { _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; {} _BlurAmount(&quot;Blur Amount&quot;, FLoat) = 1.0 } SubShader { CGINCLUDE #include &quot;UnityCG.cginc&quot; sampler2D _MainTex; fixed _BlurAmount; struct v2f { float4 pos : SV_POSITION; half2 uv : TEXCOORD0; }; v2f vert(appdata_img v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.uv = v.texcoord; return o; } fixed fragRGB(v2f i) : SV_Target { return fixed4(tex2D(_MainTex, i.uv).rgb, _BlurAmount); } half4 fragA(v2f i) : SV_Target { return tex2D(_MainTex, i.uv); } ENDCG ZTest Always Cull Off ZWrite Off Pass { Blend SrcAlpha OneMinusSrcAlpha ColorMask RGB CGPROGRAM #pragma vertex vert #pragma fragment fragRGB ENDCG } Pass { Blend One Zero ColorMask A CGPROGRAM #pragma vertex vert #pragma fragment fragA ENDCG } } Fallback Off }","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"bloom效果","date":"2017-01-24T16:00:00.000Z","path":"2017/01/25/bloom/","text":"bloom是模拟真实相机，较亮的部分扩散到周围，造成一种朦胧的感觉。 先用第一个pass筛选出原图中较亮的部分 然后在第二和第三个pass中把较亮的图像进行高斯模糊 最后在第四个pass中把模糊后的亮部和原图进行混合得到bloom效果 12345678910111213141516171819202122232425262728 void OnRenderImage(RenderTexture src, RenderTexture dest)&#123; if (material != null) &#123; material.SetFloat(\"_LuminanceThreshold\", luminanceThreshold); int rtW = src.width / downSample; int rtH = src.height / downSample; RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, 0); buffer0.filterMode = FilterMode.Bilinear; Graphics.Blit(src, buffer0, material, 0); for (int i = 0; i &lt; iterations; i++) &#123; material.SetFloat(\"_BlurSize\", 1.0f + i * blurSpread); RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0); Graphics.Blit(buffer0, buffer1, material, 1); RenderTexture.ReleaseTemporary(buffer0); buffer0 = buffer1; &#125; material.SetTexture(\"_Bloom\", buffer0); Graphics.Blit(src, dest, material, 3); RenderTexture.ReleaseTemporary(buffer0); &#125; else &#123; Graphics.Blit(src, dest); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293 Shader \"UnityShaderLearning/Bloom\"&#123; Properties &#123; _MainTex (\"Base (RGB)\", 2D) = \"white\" &#123;&#125; _Bloom (\"Bloom (RGB)\", 2D) = \"black\" &#123;&#125; _LuminanceThreshold(\"Luminance Threshold\", Float) = 0.5 _BlurSize(\"Blur Size\", Float) = 1.0 &#125; SubShader &#123; CGINCLUDE #include \"UnityCG.cginc\" sampler2D _MainTex; half4 _MainTex_TexelSize; sampler2D _Bloom; float _LuminanceThreshold; float _BlurSize; struct v2f &#123; float4 pos : SV_POSITION; half2 uv : TEXCOORD0; &#125;; v2f vertExtractBright(appdata_img v) &#123; v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.uv = v.texcoord; return o; &#125; fixed luminance(fixed4 color) &#123; return 0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b; &#125; fixed4 fragExtractBright(v2f i) : SV_Target &#123; fixed4 c = tex2D(_MainTex, i.uv); fixed val = clamp(luminance(c) - _LuminanceThreshold, 0.0, 1.0); return c * val; &#125; struct v2fBloom &#123; float4 pos : SV_POSITION; half4 uv : TEXCOORD0; &#125;; v2fBloom vertBloom(appdata_img v) &#123; v2fBloom o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.uv.xy = v.texcoord; o.uv.zw = v.texcoord; #if UNITY_UV_STARTS_AT_TOP if (_MainTex_TexelSize.y &lt; 0.0) o.uv.w = 1.0 - o.uv.w; #endif return o; &#125; fixed4 fragBloom(v2fBloom i) : SV_Target &#123; return tex2D(_MainTex, i.uv.xy) * tex2D(_Bloom, i.uv.zw); &#125; ENDCG ZTest Always Cull Off ZWrite Off Pass &#123; CGPROGRAM #pragma vertex vertBloom #pragma fragment fragBloom ENDCG &#125; UsePass \"UnityShaderLearning/GaussianBlurShader/GAUSSIAN_BLUR_VERTICAL\" UsePass \"UnityShaderLearning/GaussianBlurShader/GAUSSIAN_BLUR_HORIZONTAL\" Pass &#123; CGPROGRAM #pragma vertex vertBloom #pragma fragment fragBloom ENDCG &#125; &#125; Fallback Off&#125;","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"高斯模糊","date":"2017-01-21T16:00:00.000Z","path":"2017/01/22/gaussianblur/","text":"首先创建了一块1/downSample屏幕大小的buffer存入当前屏幕图像，然后设置滤波模式为双线性采样。这样需要处理的像素是原来的1/downSample。然后多次进行高斯模糊，逐次增大_BlurSize。 void OnRenderImage(RenderTexture src, RenderTexture dest) { if(material != null) { int rtW = src.width; int rtH = src.height; RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, 0); buffer0.filterMode = FilterMode.Bilinear; Graphics.Blit(src, buffer0); for(int i = 0; i &lt; iterations; i++) { material.SetFloat(&quot;_BlurSize&quot;, 1.0f + i * blurSpread); RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0); Graphics.Blit(buffer0, buffer1, material, 0); RenderTexture.ReleaseTemporary(buffer0); buffer0 = buffer1; buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0); Graphics.Blit(buffer0, buffer1, material, 1); RenderTexture.ReleaseTemporary(buffer0); buffer0 = buffer1; } Graphics.Blit(buffer0, dest); RenderTexture.ReleaseTemporary(buffer0); } else { Graphics.Blit(src, dest); } } 这个shader的顶点着色器用来分别计算横竖2组像素位置，片元着色器是相同的。因为高斯模糊的卷积核权重是对称的，所以可以只用一个长度为3的数组描述。顶点shader输入的uv坐标都是从当前点平移1-2个纹素得到的，比如得到当前点右边相邻的这个格子uv + (texelSiz * 1, 0) fixed4 fragBlur(v2f i) : SV_Target { float weight[3] = {0.4026, 0.2442, 0.0545}; fixed3 sum = tex2D(_MainTex, i.uv[0]).rgb * weight[0]; for (int it = 1; it &lt; 3; it++) { sum += tex2D(_MainTex, i.uv[it]).rgb * weight[it]; sum += tex2D(_MainTex, i.uv[2 * it]).rgb * weight[it]; } return fixed4(sum, 1.0); }","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"Sobel算子边缘检测","date":"2017-01-16T16:00:00.000Z","path":"2017/01/17/sobel/","text":"用Sobel算子来进行边缘检测应该知道除了Sobel算子以外还有几种常用的算子。 Roberts $$\\left[\\begin{matrix}-1 &amp; 0 \\ 0 &amp; 1\\end{matrix}\\right]$$$$\\left[\\begin{matrix}0 &amp; -1 \\1 &amp; 0\\end{matrix}\\right]$$ Prewitt $$\\left[\\begin{matrix}-1 &amp; -1 &amp; -1 \\ 0 &amp; 0 &amp; 0 \\ 1 &amp; 1 &amp; 1\\end{matrix}\\right]$$$$\\left[\\begin{matrix}-1 &amp; 0 &amp; 1 \\-1 &amp; 0 &amp; 1 \\-1 &amp; 0 &amp; 1\\end{matrix}\\right]$$ Sobel $$\\left[\\begin{matrix}-1 &amp; -2 &amp; -1 \\0 &amp; 0 &amp; 0 \\1 &amp; 2 &amp; 1\\end{matrix}\\right]$$$$\\left[\\begin{matrix}-1 &amp; 0 &amp; 1 \\-2 &amp; 0 &amp; 2 \\-1 &amp; 0 &amp; 1\\end{matrix}\\right]$$ 我们取得一个纹素的大小， 即1/texelSize。然后根据现在的纹理坐标前后左右偏移一个像素，得到9个方向的纹理坐标。然后用Sobel函数算得该纹理坐标的卷积值 _EdgeOnly = 0时显示原图像和边缘的叠加图像，即withEdgeColor _EdgeOnly = 1时只显示边缘，其他部分为背景色，即只显示onlyEdgeColor v2f vert(appdata_img v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); half2 uv = v.texcoord; o.uv[0] = uv + _MainTex_TexelSize.xy * half2(-1, -1); o.uv[1] = uv + _MainTex_TexelSize.xy * half2(0, -1); o.uv[2] = uv + _MainTex_TexelSize.xy * half2(1, -1); o.uv[3] = uv + _MainTex_TexelSize.xy * half2(-1, 0); o.uv[4] = uv + _MainTex_TexelSize.xy * half2(0, 0); o.uv[5] = uv + _MainTex_TexelSize.xy * half2(1, 0); o.uv[6] = uv + _MainTex_TexelSize.xy * half2(-1, 1); o.uv[7] = uv + _MainTex_TexelSize.xy * half2(0, 1); o.uv[8] = uv + _MainTex_TexelSize.xy * half2(1, 1); return o; } fixed luminance(fixed4 color) { return 0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b; } half Sobel(v2f i) { const half Gx[9] = { -1, -2, -1, 0, 0, 0, 1, 2, 1 }; const half Gy[9] = { -1, 0, 1, -2, 0, 2, -1, 0, 1 }; half texColor; half edgeX = 0; half edgeY = 0; for (int it = 0; it &lt; 9; it++) { texColor = luminance(tex2D(_MainTex, i.uv[it])); edgeX += texColor * Gx[it]; edgeY += texColor * Gy[it]; } half edge = 1 - abs(edgeX) - abs(edgeY); return edge; } fixed4 frag(v2f i) : SV_Target { half edge = Sobel(i); fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[4]), edge); fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge); return lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly); }","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"亮度饱和度对比度屏幕后处理效果","date":"2017-01-15T16:00:00.000Z","path":"2017/01/16/bscposteffects/","text":"以下是调节屏幕亮度饱和度对比度的关键代码，cs脚本挂在Camera上。 //给shader传对应的亮度/饱和度/对比度 void OnRenderImage(RenderTexture src, RenderTexture dest) { if(material != null) { material.SetFloat(&quot;_Brightness&quot;, brightness); material.SetFloat(&quot;_Saturation&quot;, saturation); material.SetFloat(&quot;_Contrast&quot;, contrast); Graphics.Blit(src, dest, material); } else { Graphics.Blit(src, dest); } } //fragment shader用csharp传来的值进行插值得到屏幕处理后的效果 fixed4 frag(v2f i) : SV_Target { fixed4 renderTex = tex2D(_MainTex, i.uv); fixed3 finalColor = renderTex.rgb * _Brightness; fixed luminance = 0.2125 * renderTex.r + 0.7154 * renderTex.g + 0.0721 * renderTex.b; fixed3 luminanceColor = fixed3(luminance, luminance, luminance); finalColor = lerp(luminanceColor, finalColor, _Saturation); fixed3 avgColor = fixed3(0.5, 0.5, 0.5); finalColor = lerp(avgColor, finalColor, _Contrast); return fixed4(finalColor, renderTex.a); }","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"Lua迭代器和遍历","date":"2017-01-15T16:00:00.000Z","path":"2017/01/16/luaIter/","text":"1. Lua遍历在用Lua开发过程中经常会用到一些库, 最近看到了Map类中的FindIf方法。 感觉用的很巧妙, 遂分析学习一下。FindIf方法我用原生的Lua实现了一遍, 去除了自定义的一些方法, 便于理解。 Map = {} Map.data = {} local hank = { name = &quot;hank&quot;, weight = 75 } local marry = { name = &quot;marry&quot;, weight = 50 } table.insert(Map.data, hank) table.insert(Map.data, marry) Map.Comparator = function(classNumber, equalValue) if classNumber == nil or equalValue == nil then print(&quot;参数错误! classNumber = &quot; .. tostring(classNumber) .. &quot;equalValue = &quot; .. tostring(equalValue)) end local func = function(equalValue) local comparator = function(data) return equalValue == data[classNumber] end return comparator; end return func(equalValue) end Map.Find = function(classNumber, equalValue) local comparator = Map.Comparator(classNumber, equalValue) local find = nil local index = -1; if Map.data ~= nil and #Map.data &gt; 0 then for i = 1, #Map.data do if comparator(Map.data[i]) then find = Map.data[i] index = i; break; end end end return find, index; end -- 使用示例 print(Map.Find(&quot;name&quot;, &quot;hank&quot;)) print(Map.Find(&quot;name&quot;, &quot;marry&quot;)) print(Map.Find(&quot;weight&quot;, 50)) 使用ideone运行以后输出: Success time: 0 memory: 2844 signal:0 table: 0x8573b10 1 table: 0x8573b68 2 table: 0x8573b68 2 在这里推荐一下这个在线的ide。 1.1 疑惑Map.Comparator返回的是什么?调用Map.Comparator后做了2件事: 声明一个局部变量func指向一个匿名函数function(equalValue) 调用func, 返回func的返回值。所以返回值为local comparator, 即function(data)。 Map.Comparator中的data是什么?data为调用Map.Comparator的返回值时传入的参数。比如Map.Find中comparator(Map.data[i]), Map.data[i]即为data参数。 2. Lua迭代器 next的使用```local Map = {}Map.data = {1, 2, 3}Map.it = function() return next, Map.data, nilend – 使用示例for k,v in Map.it() do print(k..v)end 使用[ideone](http://ideone.com/)运行以后输出: &gt;Success time: 0 memory: 2844 signal:0 11 22 33 - ### 自定义迭代器 local Map = {}Map.data = {1, 2, 3}Map.iter = function(data, i) print(“i: “ .. i) i = i + 1 local v = data[i] if v then return i, v endendMap.v = 0Map.it = function() return Map.iter, Map.data, Map.vend – 使用示例for k,v in Map.it() do print(“Map.v: “ .. Map.v) print(k..v)end```使用ideone运行以后输出: Success time: 0 memory: 2844 signal:0i: 0Map.v: 011i: 1Map.v: 022i: 2Map.v: 033i: 3 疑惑 next是什么next是Lua函数库中默认函数, 返回一个table的下一个值。 next (table [, index]) 运行程序来遍历表中的所有域。 第一个参数是要遍历的表，第二个参数是表中的某个键。 next 返回该键的下一个键及其关联的值。 如果用 nil 作为第二个参数调用 next 将返回初始键及其关联值。 当以最后一个键去调用，或是以 nil 调用一张空表时， next 返回 nil。 如果不提供第二个参数，将认为它就是 nil。 特别指出，你可以用 next(t) 来判断一张表是否是空的。 索引在遍历过程中的次序无定义， 即使是数字索引也是这样。 （如果想按数字次序遍历表，可以使用数字形式的 for 。） 当在遍历过程中你给表中并不存在的域赋值， next 的行为是未定义的。 然而你可以去修改那些已存在的域。 特别指出，你可以清除一些已存在的域引用自云风翻译的Lua5.3手册 for in是怎么使用这三个返回值的for in的完整形式应该是for k,v in f, s, v do, 其中f是迭代器工厂函数, s为状态/数据, v为迭代器初始值。第一次调用工厂函数生成一个迭代器, iter = f(s, v)后面每次调用迭代器iter其中data, i, v作为闭包数据保存了下来, 每次调用时i+1。 i三次迭代分别是什么值第一次i为Map.v第二次i为第一次的值保存下来后 + 1 = 2第三次i为第二次的值保存下来后 + 1 = 3","tags":[{"name":"Lua","slug":"Lua","permalink":"blog.codershu.com/tags/Lua/"}]},{"title":"透明测试","date":"2017-01-15T16:00:00.000Z","path":"2017/01/16/alphatest/","text":"AlphaTest上图为简单的AlphaTest，Alpha值小于0.55的颜色抛弃。判断的语法clip (texcoordColor.a - value)也可写作 123456789101112131415if((texcoordColor.a - value) &lt; 0.0)&#123; discard;&#125; ``` - 双面渲染 AlphaTest开启双面渲染也比较容易，只需要在`Tags=&#123; \"LightMode\"=\"ForwardBase\" &#125;`后添加一行`Cull Off`, 关闭剔除即可开启双面渲染。# 2. 透明混合(AlphaBlend)![](/assets/blogImg/UnityShader/QQ图片20161209005804.png)![](/assets/blogImg/UnityShader/QQ图片20161209005808.png) - AlphaBlend 在Pass中开启Blend即可开启透明混合，混合的公式为`混合颜色 = 当前物体Alpha * 当前颜色 + (1 - 当前Alpha) * 背景颜色` - AlphaBlendZWrite AlphaBlend的shader添加一个Pass即可开启深度写入 Pass{ZWrite OnColorMask 0} ![](/assets/blogImg/UnityShader/QQ图片20161211225510.png) `ColorMask 0`即关闭该Pass的颜色通道写入，即该Pass只执行了深度写入，然后在后续Pass中处理其他操作。开启ZWrite以后相比AlphaBlend关闭ZWrite能更好地体现前后关系。 - 双面渲染 ![](/assets/blogImg/UnityShader/QQ图片20161212001732.png) AlphaBlend的双面渲染要比AlphaTest的稍微复杂一些, 复制原来AlphaBlend的代码，写作2个Pass，分别剔除Front渲染背面和剔除Back渲染前面。 Pass{ Cull Front //原来AlphaBlend的代码}Pass{ Cull Back //原来AlphaBlend的代码} - Photoshop中AlphaBlend的几种常用模式 &gt;//正常(Normal)，透明度混合 Blend SrcAlpha OneMinusSrcAlpha &gt; &gt;//柔和相加(Soft Additive) Blend OneMinusDstColor One &gt; &gt;//正片叠底(multiply 相乘) Blend DstColor One &gt; &gt;//变暗(Darken) BlendOp Min Blend One One &gt; &gt;//变亮(Lighten) BlendOp Max Blend One One &gt; &gt;//滤色(Screen) Blend OneMinusDstColor One &gt;&gt;//等同于Blend One OneMinusSrcColor //等于D + S - D * S &gt; &gt;线性减淡(Linear Dodge) Blend One One Shader “UnityShaderLearning/AlphaTest”{ Properties { _Color (“Main Tint”, Color) = (1, 1, 1, 1) _MainTex (“Main Tex”, 2D) = “white”{} _Cutoff (“Alpha Cutoff”, Range(0, 1)) = 0.55 } SubShader { Tags { “Queue”=”AlphaTest” “IgnoreProjector” = “True” “RenderType”=”TransparentCutout”} Pass { Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; } CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; fixed _Cutoff; struct a2v { float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; float2 uv : TEXCOORD2; }; v2f vert(a2v v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(_Object2World, v.vertex).xyz; o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); return o; } fixed4 frag(v2f i) : SV_Target { fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); fixed4 texColor = tex2D(_MainTex, i.uv); clip (texColor.a - _Cutoff); fixed3 albedo = texColor.rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir)); return fixed4(ambient + diffuse, 1.0); } ENDCG } } FallBack &quot;Transparent/Cutout/VertexLit&quot; } Shader “UnityShaderLearning/AlphaBlend”{ Properties { _Color (“Main Tint”, Color) = (1, 1, 1, 1) _MainTex (“Main Tex”, 2D) = “white”{} _AlphaScale (“Alpha Scale”, Range(0, 1)) = 1 } SubShader { Tags { &quot;Queue&quot;=&quot;AlphaTest&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;TransparentCutout&quot;} Pass { Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; } ZWrite Off Blend SrcAlpha OneMinusSrcAlpha CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; fixed _AlphaScale; struct a2v { float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; float2 uv : TEXCOORD2; }; v2f vert(a2v v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(_Object2World, v.vertex).xyz; o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); return o; } fixed4 frag(v2f i) : SV_Target { fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); fixed4 texColor = tex2D(_MainTex, i.uv); fixed3 albedo = texColor.rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir)); return fixed4(ambient + diffuse, texColor.a * _AlphaScale); } ENDCG } } FallBack &quot;Transparent/VertexLit&quot; }```","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"广告牌","date":"2017-01-13T16:00:00.000Z","path":"2017/01/14/billboarding/","text":"我们根据设置的法线y方向偏移来得到偏移后的法线，然后和upDir叉乘得到右方向，最后用法线和右方向叉乘得到准确的upDir。最后把顶点坐标通过我们构造的矩阵进行变化，从而得到新的顶点坐标，最后转换到观察空间。我们就可以得到始终面向我们的物体。 Shader &quot;UnityShaderlearning/BillBoarding&quot; { Properties { _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; {} _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1) _VerticalBillboarding (&quot;Vertical Restraints&quot;, Range(0, 1)) = 1 } SubShader { Tags { &quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;DisableBatching&quot;=&quot;True&quot; } Pass { Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; } ZWrite Off Blend SrcAlpha OneMinusSrcAlpha Cull Off CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; sampler2D _MainTex; float4 _MainTex_ST; fixed4 _Color; fixed _VerticalBillboarding; struct a2v { float4 vertex : POSITION; float4 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float2 uv : TEXCOORD0; }; v2f vert(a2v v) { v2f o; float3 center = float3(0, 0, 0) float3 viewer = mul(_World2Object, float4(_WorldSpaceCameraPos, 1)); float3 normalDir = viewer - center; normalDir.y = normalDir.y * _VerticalBillboarding; normalDir = normalize(normalDir); float3 upDir = abs(normalDir.y) &gt; 0.99 ? float3(0, 0, 1) : float3(0, 1, 0); float3 rightDir = normalize(cross(upDir, normalDir)); upDir = normalize(cross(normalDir, rightDir)); floar3 centerOffs = v.vertex.xyz - center; floar3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y = normalDir * centerOffs.z; o.pos = mul(UNITY_MATRIX_MVP, float4(localPos, 1)); o.uv = TRANSFORM_TEX(v.texcoord,_MainTex); return o; } fixed4 frag(v2f i) : SV_Target { fixed4 c = tex2D (_MainTex, i.uv); c.rgb *= _Color.rgb; return c; } ENDCG } } Fallback &quot;Transparent/VertexLit&quot; }","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"顶点动画","date":"2017-01-10T16:00:00.000Z","path":"2017/01/11/uvanimationshader/","text":"对顶点进行位移以使得图片看起来像动画 _Frequency 是震动频率 _InvWaveLength 是波长的倒数 _Magnitude 是振幅 Shader &quot;UnityShaderLearning/UVAnimation&quot; { Properties { _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; {} _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1) _Magnitude(&quot;Distortion Magnitude&quot;, Float) = 1 _Frequency (&quot;Distortion Frequency&quot;, Float) = 1 _InvWaveLength (&quot;Distortion Inverse Wave Length&quot;, Float) = 10 _Speed (&quot;Speed&quot;, Float) = 0.5 } SubShader { Tags {&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;DisableBatching&quot;=&quot;True&quot; } Pass { Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; } ZWrite Off Blend SrcAlpha OneMinusSrcAlpha Cull Off CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;UnityCG.cginc&quot; sampler2D _MainTex; float4 _MainTex_ST; fixed4 _Color; float _Magnitude; float _Frequency; float _InvWaveLength; float _Speed; struct a2v { float4 vertex : POSITION; float2 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float2 uv : TEXCOORD0; }; v2f vert(a2v v) { v2f o; float4 offset; offset.yzw = float3(0.0, 0.0, 0.0); offset.x = sin(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude; o.pos = mul ( UNITY_MATRIX_MVP, v.vertex + offset); o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); o.uv += float2(0.0, _Time.y * _Speed); return o; } fixed4 frag(v2f i) : SV_Target { fixed4 c = tex2D(_MainTex, i.uv); c.rgb *= _Color.rgb; return c; } ENDCG } } Fallback &quot;Transparent/VertexLit&quot; }","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"序列帧动画","date":"2017-01-08T16:00:00.000Z","path":"2017/01/09/imagesequence/","text":"用shader对序列帧图片进行采样，以实现动画效果。 Shader &quot;UnityShaderLearning/ImageSequenceAni&quot; { Properties { _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1) _MainTex (&quot;Image Sequence&quot;, 2D) = &quot;white&quot;{} _HorizontalAmount (&quot;Horizontal Amount&quot;, Float) = 4 _VertcalAmount (&quot;Vertcal Amount&quot;, Float) = 4 _Speed (&quot;Speed&quot;, Range(1, 100)) = 30 } SubShader { Tags { &quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; } Pass { Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; } ZWrite Off Blend SrcAlpha OneMinusSrcAlpha CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;UnityCG.cginc&quot; fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; float _HorizontalAmount; float _VertcalAmount; float _Speed; struct a2v { float4 vertex : POSITION; float2 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float2 uv : TEXCOORD0; }; v2f vert(a2v v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); return o; } fixed4 frag(v2f i) : SV_Target { float time = floor(_Time.y * _Speed); float row = floor(time / _HorizontalAmount); float col = floor(time / _VertcalAmount); half2 uv = i.uv + half2(col, -row); uv.x /= _HorizontalAmount; uv.y /= _VertcalAmount; fixed4 color = tex2D(_MainTex, uv); color.rgb *= _Color; return color; } ENDCG } } FallBack &quot;Transparent/VertexLit&quot; }","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"程序纹理","date":"2017-01-05T16:00:00.000Z","path":"2017/01/06/proceduraltexturegeneration/","text":"性能消耗以秒计…不实用。 private Texture2D GenerateProceduralTexture() { Texture2D pTex = new Texture2D(textureWidth, textureWidth); float circleInterval = textureWidth / 4.0f; float radius = textureWidth / 10.0f; float edgeBlur = 1.0f / blurFactor; for(int w = 0; w &lt; textureWidth; w++) { for(int h = 0; h &lt; textureWidth; h++) { Color pixel = backgroundColor; for (int i = 0; i &lt; 3; i++) { for(int j = 0; j &lt; 3; j++) { Vector2 circleCenter = new Vector2(circleInterval * (i + 1), circleInterval * (j + 1)); float dist = Vector2.Distance(new Vector2(w, h), circleCenter) - radius; Color color = MixColor(circleColor, new Color(pixel.r, pixel.g, pixel.b, 0.0f), Mathf.SmoothStep(0f, 1.0f, dist * edgeBlur)); pixel = MixColor(pixel, color, color.a); } } pTex.SetPixel(w, h, pixel); } } pTex.Apply(); return pTex; } private Color MixColor(Color color0, Color color1, float mixFactor) { Color mixColor = Color.white; mixColor.r = Mathf.Lerp(color0.r, color1.r, mixFactor); mixColor.g = Mathf.Lerp(color0.g, color1.g, mixFactor); mixColor.b = Mathf.Lerp(color0.b, color1.b, mixFactor); mixColor.a = Mathf.Lerp(color0.a, color1.a, mixFactor); return mixColor; } 性能消耗以秒计…不实用。","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"玻璃透明效果","date":"2017-01-04T16:00:00.000Z","path":"2017/01/05/glassrefraction/","text":"用ComputeGrabScreenPos取得被抓取的屏幕的对应对标。 计算出切线空间到世界坐标的转换矩阵，存在3个float4中，剩下的一位存入worldPos。 用_Distortion和_RefractionTex_TexelSize来计算出一个偏移量来偏移屏幕采样坐标，模拟折射的效果。 用反射方向对Cubemap采样，得到反射颜色，反射颜色+折射颜色得到最后的输出颜色。 Shader &quot;UnityShaderLearning/GlassRefraction&quot; { Properties { _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; {} _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; {} _Cubemap (&quot;Environment Cubemap&quot;, Cube) = &quot;_Skybox&quot; {} _Distortion (&quot;Distortion&quot;, Range(0, 100)) = 10 _RefractAmount (&quot;Refract Amount&quot;, Range(0.0, 1.0)) = 1.0 } SubShader { Tags { &quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Opaque&quot; } GrabPass { &quot;_RefractionTex&quot; } Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;UnityCG.cginc&quot; sampler2D _MainTex; float4 _MainTex_ST; sampler2D _BumpMap; float4 _BumpMap_ST; samplerCUBE _Cubemap; float _Distortion; fixed _RefractAmount; sampler2D _RefractionTex; float4 _RefractionTex_TexelSize; struct a2v { float4 vertex : POSITION; float2 texcoord : TEXCOORD0; float3 normal : NORMAL; float4 tangent : TANGENT; }; struct v2f { float4 pos : SV_POSITION; float4 scrPos : TEXCOORD0; float4 uv : TEXCOORD1; float4 TtoW0 : TEXCOORD2; float4 TtoW1 : TEXCOORD3; float4 TtoW2 : TEXCOORD4; }; v2f vert (a2v v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.scrPos = ComputeGrabScreenPos(o.pos); o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex); o.uv.zw = TRANSFORM_TEX(v.texcoord, _BumpMap); float3 worldPos = mul(_Object2World, v.vertex).xyz; fixed3 worldNormal = UnityObjectToWorldNormal(v.normal); fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz); fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w; o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x); o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y); o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z); return o; } fixed4 frag(v2f i) : SV_Target { float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w); fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos)); fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw)); float2 offset = bump.xy * _Distortion * _RefractionTex_TexelSize.xy; i.scrPos.xy = offset + i.scrPos.xy; fixed3 RefrCol = tex2D(_RefractionTex, i.scrPos.xy/i.scrPos.w).rgb; bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump))); fixed3 reflDir = reflect(-worldViewDir, bump); fixed4 texColor = tex2D(_MainTex, i.uv.xy); fixed3 reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb; fixed3 finalColor = reflCol * (1 - _RefractAmount) + RefrCol * _RefractAmount; return fixed4(finalColor, 1); } ENDCG } } FallBack &quot;Diffuse&quot; }","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"镜子效果","date":"2016-12-27T16:43:00.000Z","path":"2016/12/28/mirror/","text":"一个简单的shader就能实现镜子的效果。在镜子的位置放一个相机，把相机的RenderTexture翻转，1 - uv.x。 Shader &quot;UnityShaderLearning/Mirror&quot; { Properties { _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; {} } SubShader { Tags { &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot; } Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag sampler2D _MainTex; struct a2v { float4 vertex : POSITION; float3 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float2 uv : TEXCOORD0; }; v2f vert(a2v v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.uv = v.texcoord; o.uv.x = 1 - o.uv.x; return o; } fixed4 frag(v2f i):SV_Target { return tex2D(_MainTex, i.uv); } ENDCG } } FallBack Off }","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"反射材质","date":"2016-12-21T18:01:00.000Z","path":"2016/12/22/reflection/","text":"这是使用了反射材质的水壶，模拟了金属反射室内的情况。室内用的是一个天空球模拟的。 fixed fresnel = _FresnelScale + (1 - _FresnelScale) * pow(1 - dot(worldViewDir, worldNormal), 5); 在片元着色器添加一行菲涅尔反射用的参数，然后将正常的ReflectionShader的_ReflectAmount换成新计算的fresnel，改变插值的系数。 Shader &quot;UnityShaderLearning/Reflection&quot; { Properties { _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1) _ReflectColor (&quot;Reflection Color&quot;, Color) = (1, 1, 1, 1) _ReflectAmount (&quot;Reflect Amount&quot;, Range(0, 1)) = 1 _Cubemap (&quot;Reflection Cubemap&quot;, Cube) = &quot;_Skybox&quot; {} } SubShader { Tags { &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot; } Pass { Tags { &quot;Lighting&quot;=&quot;ForwardBase&quot; } CGPROGRAM #pragma multi_compile_fwdbase #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; #include &quot;AutoLight.cginc&quot; fixed4 _Color; fixed4 _ReflectColor; fixed _ReflectAmount; samplerCUBE _Cubemap; struct a2v { float4 vertex : POSITION; float3 normal : NORMAL; }; struct v2f { float4 pos : SV_POSITION; fixed3 worldPos : TEXCOORD0; fixed3 worldNormal : TEXCOORD1; fixed3 worldViewDir : TEXCOORD2; fixed3 worldRefl : TEXCOORD3; SHADOW_COORDS(4) }; v2f vert(a2v v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(_Object2World, v.vertex).xyz; o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos); o.worldRefl = reflect(-o.worldViewDir, o.worldNormal); TRANSFER_SHADOW(o); return o; } fixed4 frag(v2f i) : SV_Target { fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); fixed3 worldViewDir = normalize(i.worldViewDir); fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(0, dot(worldNormal, worldLightDir)); fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb * _ReflectColor.rgb; UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos); fixed3 color = ambient + lerp(diffuse, reflection, _ReflectAmount) * atten; return fixed4(color, 1.0); } ENDCG } } FallBack &quot;Reflective/VertexLit&quot; }","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"实时阴影","date":"2016-12-15T02:42:00.000Z","path":"2016/12/15/shadow/","text":"1. Unity内部的ShadowCasterShaderPass { Name &quot;ShadowCaster&quot; Tags { &quot;LightMode&quot;=&quot;ShadowCaster&quot; } CGPROGRAM #pragma vertex vert #pragma fragment frag #pragma multi_compile_shadowcaster #include &quot;UnityCG.cginc&quot; struct v2f { V2F_SHADOW_CASTER; }; v2f vert(appdata_base v) { v2f o; TRANSFER_SHADOW_CASTER_NORMALOFFSET(o) return o; } float4 frag(v2f i) : SV_Target { SHADOW_CASTER_FRAGMENT(i) } ENDCG } 2. ShadowRecv 在ForwardRendering.shader中添加SHADOW_COORDS TRANSFER_SHADOW SHADOW_ATTENUATION即可变成ShadowRecv.shader Shader &quot;UnityShaderLearning/ShadowRecv&quot; { Properties { _Diffuse(&quot;Diffuse&quot;, Color) = (1, 1, 1, 1) _Specular(&quot;Specular&quot;, Color) = (1, 1, 1, 1) _Gloss(&quot;Gloss&quot;, Range(8.0, 256)) = 20 } SubShader { Pass { Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; } CGPROGRAM #pragma multi_compile_fwbase #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; #include &quot;AutoLight.cginc&quot; fixed4 _Diffuse; fixed4 _Specular; float _Gloss; struct a2v { float4 vertex : POSITION; float3 normal : NORMAL; }; struct v2f { float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; SHADOW_COORDS(2) }; v2f vert(a2v v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.worldNormal = normalize(mul(v.normal, (float3x3)_World2Object)); o.worldPos = mul(_Object2World, v.vertex).xyz; TRANSFER_SHADOW(o); return o; } fixed4 frag(v2f i) :SV_Target { fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir)); fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz); fixed3 halfDir = normalize(viewDir + worldLightDir); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(worldNormal, halfDir)), _Gloss); fixed atten = 1.0; fixed4 shadow = SHADOW_ATTENUATION(i); return fixed4(ambient + (diffuse + specular) * atten * shadow, 1.0); } ENDCG } Pass { Tags { &quot;LightMode&quot;=&quot;ForwardAdd&quot; } Blend SrcAlpha One CGPROGRAM #pragma multi_compile_fwbase #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; #include &quot;AutoLight.cginc&quot; fixed4 _Diffuse; fixed4 _Specular; float _Gloss; struct a2v { float4 vertex : POSITION; float3 normal : NORMAL; }; struct v2f { float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; }; v2f vert(a2v v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(_Object2World, v.vertex).xyz; return o; } fixed4 frag(v2f i) : SV_Target { fixed3 worldNormal = normalize(i.worldNormal); #ifdef USING_DIRECTIONAL_LIGHT fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); #else fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz - i.worldPos.xyz); #endif fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(0, dot(worldNormal, worldLightDir)); fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz); fixed3 halfDir = normalize(worldLightDir + viewDir); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss); #ifdef USING_DIRECTIONAL_LIGHT fixed atten = 1.0; #else #if defined (POINT) float3 lightCoord = mul(_LightMatrix0, float4(i.worldPos, 1)).xyz; fixed atten = tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL; #elif defined (SPOT) float4 lightCoord = mul(_LightMatrix0, float4(i.worldPos, 1)); fixed atten = (lightCoord.z &gt; 0) * tex2D(_LightTexture0, lightCoord.xy / lightCoord.w + 0.5).w * tex2D(_LightTextureB0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL; #else fixed atten = 1.0; #endif #endif return fixed4((diffuse + specular) * atten, 1.0); } ENDCG } } FallBack &quot;Specular&quot; } 3. 透明物体的阴影效果 Shader &quot;UnityShaderLearning/AlphaTestWithShadow&quot; { Properties { _Color (&quot;Main Tint&quot;, Color) = (1, 1, 1, 1) _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot;{} _Cutoff (&quot;Alpha Cutoff&quot;, Range(0, 1)) = 0.55 } SubShader { Tags { &quot;Queue&quot;=&quot;AlphaTest&quot; &quot;IgnoreProjector&quot; = &quot;True&quot; &quot;RenderType&quot;=&quot;TransparentCutout&quot;} Pass { Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; } Cull Off CGPROGRAM #pragma multi_compile_fwdbase #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; #include &quot;AutoLight.cginc&quot; fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; fixed _Cutoff; struct a2v { float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; float2 uv : TEXCOORD2; SHADOW_COORDS(3) }; v2f vert(a2v v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(_Object2World, v.vertex).xyz; o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); TRANSFER_SHADOW(o); return o; } fixed4 frag(v2f i) : SV_Target { fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); fixed4 texColor = tex2D(_MainTex, i.uv); clip (texColor.a - _Cutoff); fixed3 albedo = texColor.rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir)); UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos); return fixed4(ambient + diffuse * atten, 1.0); } ENDCG } } FallBack &quot;VertexLit&quot; }","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"Lua OO 实现 ","date":"2016-12-09T13:49:00.000Z","path":"2016/12/09/luaoo/","text":"Lua OO 实现##1. 类的实现12345678910111213141516171819testClass =&#123; id, num&#125;;testClass.__index = testClassfunction testClass:new(id, num) local self = &#123;&#125; setmetatable(self, testClass) self.id = id self.num = num return selfendfunction testClass:PrintNum() print(\"num is \" .. self.num)end 简单使用12local obj = testClass:new(10, 11)obj:PrintNum() 得到输出num is 11 ##2. 类的继承Class A123456789101112131415161718A = &#123;&#125;function A:new(o) o = o or &#123;&#125; //self指向o setmetatable(o, self) //__index设为A self.__index = self return o;endfunction A:PrintClassName() print(\"this is class A\")endfunction A:AMethod() print(\"this is AMethod !\")end Class B继承Class A12345B = A:new()function B:PrintClassName() print(\"this is class B !\")end 使用示例123local obj = B:new()obj:PrintClassName()obj:AMethod() 输出 this is class B ! this is AMethod !","tags":[{"name":"Lua","slug":"Lua","permalink":"blog.codershu.com/tags/Lua/"}]},{"title":"Unity和Java交互","date":"2016-12-07T20:42:00.000Z","path":"2016/12/08/CSharpAndJava/","text":"#CSharpToJava ##1. new Java类12345678910static AndroidJavaClass _UnityPlayer;static AndroidJavaClass unityPlayer&#123; get &#123; if (_UnityPlayer == null) _UnityPlayer = new AndroidJavaClass(\"com.unity3d.player.UnityPlayer\"); return _UnityPlayer; &#125;&#125; ##2. 调用Java函数 调用无参无返回函数 12//调用静态函数为CallStaticandroidJavaClass.Call(\"methodName\"); 调用带参数有返回函数 1234567891011121314//返回值为int则为Call&lt;int&gt;//返回值为Java自定义的数据类型, 比如Java类。则为CallStatic&lt;AndroidJavaObject&gt;//调用静态函数为CallStaticString str = androidJavaClass.Call&lt;String&gt;(\"methodName\", param1, param2);``` &lt;!-- more --&gt;##3. 访问Java类的属性- 访问普通属性``` //访问int属性则为Get&lt;int&gt;String str = androidJavaClass.Get&lt;String&gt;(\"PropertyName\")``` - 访问静态属性 //示例如下:unityPlayer.GetStatic(“currentActivity”)1234#JavaToCSharp ## 1. Java调用CSharp**需要在场景中创建一个名为AScript的GameObject** //调用场景中的GameObject:AScript挂载的脚本AScript中的BMethod，传入参数param。UnityPlayer.UnitySendMessage(“AScript”,”BMethod”, param);```","tags":[{"name":"Unity - Java - C#","slug":"Unity-Java-C","permalink":"blog.codershu.com/tags/Unity-Java-C/"}]},{"title":"遮罩纹理","date":"2016-12-07T15:55:00.000Z","path":"2016/12/07/masktexture/","text":"左图使用了遮罩纹理，右侧是普通的Blin-Phone模型，在高光上表现得更加细腻。 上图是使用了主纹理/法线贴图/遮罩纹理的效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283Shader \"UnityShaderLearning/MaskTexture\" &#123; Properties &#123; _Color (\"Color Tint\", Color) = (1, 1, 1, 1) _MainTex (\"Main Tex\", 2D) = \"white\"&#123;&#125; _BumpMap (\"Nomral Map\", 2D) = \"bump\"&#123;&#125; _BumpScale(\"Bump Scale\", Float) = 1.0 _SpecularMask (\"Specular Mask\", 2D) = \"white\"&#123;&#125; _SpecularScale (\"Specular Scale\", Float) = 1.0 _Specular (\"Specular\", Color) = (1, 1, 1, 1) _Gloss (\"Gloss\", Range(8.0, 256)) = 20 &#125; SubShader &#123; Pass &#123; Tags &#123; \"LightMode\"=\"ForwardBase\" &#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"Lighting.cginc\" fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; sampler2D _BumpMap; float _BumpScale; sampler2D _SpecularMask; float _SpecularScale; fixed4 _Specular; float _Gloss; struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; float4 texcoord : TEXCOORD0; &#125;; struct v2f &#123; float4 pos : SV_POSITION; float2 uv : TEXCOORD0; float3 lightDir : TEXCOORD1; float3 viewDir : TEXCOORD2; &#125;; v2f vert(a2v v) &#123; v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.uv.xy = v.texcoord.xy * _MainTex_ST.xy * _MainTex_ST.zw; TANGENT_SPACE_ROTATION; o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz; o.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz; return o; &#125; fixed4 frag(v2f i) : SV_Target &#123; fixed3 tangentLightDir = normalize(i.lightDir); fixed3 tangentViewDir = normalize(i.viewDir); fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uv)); tangentNormal.xy *= _BumpScale; tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy))); fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(tangentNormal, tangentLightDir)); fixed3 halfDir = normalize(tangentLightDir + tangentViewDir); fixed specularMask = tex2D(_SpecularMask, i.uv).r * _SpecularScale; fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(tangentNormal, halfDir)), _Gloss) * specularMask; return fixed4(ambient + diffuse + specular, 1.0); &#125; ENDCG &#125; &#125; FallBack \"Diffuse\"&#125;","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"渐变纹理","date":"2016-12-06T17:07:00.000Z","path":"2016/12/07/ramptexture/","text":"12fixed halfLambert = 0.5 * dot(worldNormal, worldLightDir) + 0.5;fixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert, halfLambert)).rgb * _Color.rgb; 关键代码有两行 第一行代码获得了法线和光线方向的夹角的余弦值*0.5 + 0.5, 即把余弦值映射到[0, 1]。 第二行代码在渐变纹理上采样 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Shader \"UnityShaderLearning/RampTexture\" &#123; Properties &#123; _Color (\"Color Tint\", Color) = (1,1,1,1) _RampTex (\"Ramp Tex\", 2D) = \"white\" &#123;&#125; _Specular (\"Specular\", Color) = (1, 1, 1, 1) _Gloss (\"Gloss\", Range(8.0, 256)) = 20 &#125; SubShader &#123; Pass &#123; Tags &#123; \"LightMode\"=\"ForwardBase\" &#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"Lighting.cginc\" fixed4 _Color; sampler2D _RampTex; float4 _RampTex_ST; fixed4 _Specular; float _Gloss; struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord : TEXCOORD0; &#125;; struct v2f &#123; float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; float2 uv : TEXCOORD2; &#125;; v2f vert(a2v v) &#123; v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(_Object2World, v.vertex).xyz; o.uv = TRANSFORM_TEX(v.texcoord, _RampTex); return o; &#125; fixed4 frag(v2f i) : SV_Target &#123; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed halfLambert = 0.5 * dot(worldNormal, worldLightDir) + 0.5; fixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert, halfLambert)).rgb * _Color.rgb; fixed3 diffuse = _LightColor0.rgb * diffuseColor; fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos)); fixed3 halfDir = normalize(worldLightDir + viewDir); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss); return fixed4(ambient + diffuse + specular, 1.0); &#125; ENDCG &#125; &#125; FallBack \"Diffuse\"&#125;","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"切线空间下的法线贴图应用","date":"2016-12-06T16:26:00.000Z","path":"2016/12/07/normalmaptangentspace/","text":"左侧BumpScale为-1 右侧BumpScale为1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889Shader \"UnityShaderLearning/NormalMapTangentSpace\"&#123; Properties &#123; _Color(\"Color Tint\", Color) = (1, 1, 1, 1) _MainTex(\"Main Tex\", 2D) = \"white\"&#123;&#125; _BumpMap(\"Normal Map\", 2D) = \"bump\"&#123;&#125; _BumpScale(\"Bump Scale\", Float) = 1.0 _Specular(\"Specular\", Color) = (1, 1, 1, 1) _Gloss(\"Gloss\", Range(8.0, 256)) = 20 &#125; SubShader &#123; Pass &#123; Tags &#123; \"LightMode\"=\"ForwardBase\" &#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"Lighting.cginc\" fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; sampler2D _BumpMap; float4 _BumpMap_ST; float _BumpScale; fixed4 _Specular; float _Gloss; struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; float4 texcoord : TEXCOORD0; &#125;; struct v2f &#123; float4 pos : SV_POSITION; float4 uv : TEXCOORD0; float3 LightDir : TEXCOORD1; float3 ViewDir : TEXCOORD2; &#125;; v2f vert(a2v v) &#123; v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.uv.xy = v.vertex.xy * _MainTex_ST.xy + _MainTex_ST.zw; o.uv.zw = v.vertex.xy * _BumpMap_ST.xy + _BumpMap_ST.zw; float3 binormal = cross(normalize(v.normal), normalize(v.tangent.xyz)); float3x3 rotation = float3x3(v.tangent.xyz, binormal, v.normal); o.LightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz; o.ViewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz; return o; &#125; fixed4 frag(v2f i) : SV_Target &#123; fixed3 tangentLightDir = normalize(i.LightDir); fixed3 tangentViewDir = normalize(i.ViewDir); fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw); fixed3 tangentNormal; // tangentNormal.xy = (packedNormal.xy * 2 - 1) * _BumpScale; // tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy))); tangentNormal = UnpackNormal(packedNormal); tangentNormal.xy *= _BumpScale; tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy))); fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(tangentNormal, tangentLightDir)); fixed3 halfDir = normalize(tangentViewDir + tangentLightDir); fixed3 specular = _LightColor0 * _Specular.rgb * pow(max(0, dot(tangentNormal, halfDir)), _Gloss); return fixed4(ambient + diffuse + specular, 1.0); &#125; ENDCG &#125; &#125; FallBack \"specular\"&#125;","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"逐顶点和逐像素的高光模型","date":"2016-11-18T17:26:00.000Z","path":"2016/11/19/specularvertexlevelpixellevel/","text":"左为逐顶点高光Phong模型 中为逐像素高光Phong模型 右为逐像素高光Blinn-Phong模型 Phong模型$$C{specular=(c{light}*m{specular})max(0, \\vec{v}·\\vec{r})^{m{Gloss}}}$$ Blinn-Phong模型$$C{specular=(c{light}*m{specular})max(0, \\vec{n}·\\vec{h})^{m{Gloss}}}$$ $$\\vec{h} = \\frac{\\vec{v}·\\vec{i}}{|v||i|}$$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Shader &quot;UnityShaderLearning/SpecularVertexLevel&quot;&#123; Properties &#123; _Diffuse(&quot;Diffuse&quot;, Color) = (1, 1, 1, 1) _Specular(&quot;Specular&quot;, Color) = (1, 1, 1, 1) _Gloss(&quot;Gloss&quot;, Range(8.0, 256)) = 20 &#125; SubShader &#123; Pass &#123; Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; fixed4 _Diffuse; fixed4 _Specular; float _Gloss; struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; &#125;; struct v2f &#123; float4 pos : SV_POSITION; float3 color : COLOR; &#125;; v2f vert(a2v v) &#123; v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 worldNormal = normalize(mul(v.normal, (float3x3)_World2Object)); fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir)); fixed3 reflectDir = normalize(reflect(-worldLightDir, worldNormal)); fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - mul(_Object2World, v.vertex).xyz); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(reflectDir, viewDir)), _Gloss); o.color = ambient + diffuse + specular; return o; &#125; fixed4 frag(v2f i) :SV_Target &#123; return fixed4(i.color, 1.0); &#125; ENDCG &#125; &#125; FallBack &quot;Specular&quot;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Shader \"UnityShaderLearning/SpecularPixelLevel\"&#123; Properties &#123; _Diffuse(\"Diffuse\", Color) = (1, 1, 1, 1) _Specular(\"Specular\", Color) = (1, 1, 1, 1) _Gloss(\"Gloss\", Range(8.0, 256)) = 20 &#125; SubShader &#123; Pass &#123; Tags &#123; \"LightMode\"=\"ForwardBase\" &#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"Lighting.cginc\" fixed4 _Diffuse; fixed4 _Specular; float _Gloss; struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; &#125;; struct v2f &#123; float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; &#125;; v2f vert(a2v v) &#123; v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.worldNormal = normalize(mul(v.normal, (float3x3)_World2Object)); o.worldPos = mul(_Object2World, v.vertex).xyz; return o; &#125; fixed4 frag(v2f i) :SV_Target &#123; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir)); fixed3 reflectDir = normalize(reflect(-worldLightDir, worldNormal)); fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(reflectDir, viewDir)), _Gloss); fixed3 color = ambient + diffuse + specular; return fixed4(color, 1.0); &#125; ENDCG &#125; &#125; FallBack \"Specular\"&#125;``` ``` fixed3 halfDir = normalize(viewDir + worldLightDir);fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(worldNormal, halfDir)), _Gloss);","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"DiffuseVertexLevel/PixelLevel(漫反射)","date":"2016-11-17T16:24:00.000Z","path":"2016/11/18/diffuseshadervertexlevel/","text":"左为逐顶点漫反射光照模型，右为逐像素漫反射光照模型。 漫反射光照模型$$C{diffuse}=(C{light} * m_{diffuse})max(0, \\vec{n}·\\vec{i})$$ $$C_{light}$$入射光颜色和强度 $$m_{diffuse}$$材质漫反射系数 $$\\vec{n}$$法线方向 $$\\vec{i}$$光源方向 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Shader \"UnityShaderLearning/DiffuseVertexLevel\"&#123; Properties &#123; _Diffuse(\"Diffuse\", Color) = (1, 1, 1, 1) &#125; SubShader &#123; Pass &#123; Tags&#123; \"LightMode\"=\"ForwardBase\" &#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"Lighting.cginc\" fixed4 _Diffuse; struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; &#125;; struct v2f &#123; float4 pos : SV_POSITION; fixed3 color : COLOR; &#125;; v2f vert(a2v v) &#123; v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 worldNormal = normalize(mul(v.normal, (float3x3)_World2Object)); fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz); fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLight)); o.color = ambient + diffuse; return o; &#125; fixed4 frag(v2f i) : SV_Target &#123; return fixed4(i.color, 1.0); &#125; ENDCG &#125; &#125; FallBack \"Diffuse\"&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Shader \"UnityShaderLearning/DiffusePixelLevel\"&#123; Properties &#123; _Diffuse(\"Diffuse\", Color) = (1, 1, 1, 1) &#125; SubShader &#123; Pass &#123; Tags&#123; \"LightMode\" = \"ForwardBase\" &#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"Lighting.cginc\" fixed4 _Diffuse; struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; &#125;; struct v2f &#123; float4 pos : SV_POSITION; fixed3 worldNormal : TEXCOORD0; &#125;; v2f vert(a2v v) &#123; v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.worldNormal =mul(v.normal, (float3x3)_World2Object); return o; &#125; fixed4 frag(v2f i) : SV_Target &#123; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir)); fixed3 color = ambient + diffuse; return fixed4(color, 1.0); &#125; ENDCG &#125; &#125; FallBack \"Diffuse\"&#125;","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"AssetBundle冗余检测器","date":"2016-11-10T16:00:00.000Z","path":"2016/11/11/assetbundleRedencyCheck/","text":"最近我们项目快上线了，把项目提交到了一个专业做Unity项目优化的网站。——uwa 他们号称没有不存在资源冗余的项目，我们提交以后确实发现了一些冗余资源。但是他们网站有2个缺陷： 免费用户一个月只能检测2次 不自由 付费用户6600/季度 需要上传自己项目的所有AB文件 不安全 而且，我仔细想了下，这里面的技术其实不是很复杂。就衍生了一个自己写一个小插件的想法，然后ABRedundancyChecker就诞生了。 一、插件介绍 我把AB包所有的资源分为两类 本包资源 依赖包资源 该插件把每个AB包的本包资源都列举出来，然后统计这些资源是否有重复，重复则为冗余。 插件github仓库地址：https://github.com/inkiu0/ABRedundancyChecker 喜欢的赏颗星星 二、ABRedundancyChecker使用方法1. 修改脚本参数 把以下参数改成自己想要的: 1234567891011121314151617181920212223242526272829303132333435/// &lt;summary&gt;/// AB文件名匹配规则/// &lt;/summary&gt;public string searchPattern = \"*.ab\";/// &lt;summary&gt;/// 冗余资源类型白名单/// &lt;/summary&gt;public List&lt;Type&gt; assetTypeList = new List&lt;Type&gt; &#123; typeof(Material), typeof(Texture2D), typeof(AnimationClip),typeof(AudioClip), typeof(Sprite), typeof(Shader), typeof(Font), typeof(Mesh) &#125;;/// &lt;summary&gt;/// 输出路径/// &lt;/summary&gt;public string outPath = Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory);/// &lt;summary&gt;/// AB文件存放路径，会从这个文件夹下递归查找符合查找规则searchPattern的文件。/// &lt;/summary&gt;public string abPath = \"Assets/StreamingAssets\";[MenuItem(\"AB冗余检测/AB检测\")] 2. 开始使用 将ABRedundancyChecker.cs放在Unity项目的Editor目录下 将所有打包好的AssetBundle文件放在abPath目录下 点击菜单栏AB冗余检测-&gt;AB检测 喝一杯茶 250MB的AB文件(1600个文件)检测时间为2分钟 打开输出到目标目录的MarkDown文件 3. 输出的MarkDown形如","tags":[{"name":"Unity","slug":"Unity","permalink":"blog.codershu.com/tags/Unity/"}]},{"title":"AVL树和红黑树 ","date":"2016-10-30T16:00:00.000Z","path":"2016/10/31/RBTree/","text":"技术分享会旨在：抛砖引玉，促进程序之间互相交流，培养公司内部良好的技术氛围。 1. Base此次分享会默认大家清楚了解以下知识点： 二叉查找树(binary search tree)的定义和实现 AVL树的定义和实现 基础的C/C++知识 此次分享会主要和大家分享探讨以下内容 AVL树和红黑树的异同 树的旋转 红黑树的在STL中的应用(SGI STL) 红黑树在跳跃表中的应用 2. AVL树和红黑树的性质###AVL树 高度为h的AVL树最少有S(h) = S(h-1) + S(h-2) + 1个节点 $$S(h) = \\frac{1}{\\sqrt{5}}((\\frac{1+\\sqrt{5}}{2})^{h+2} - (\\frac{1-\\sqrt{5}}{2})^{h+2}) - 1$$ $$\\because \\frac{(\\frac{1-\\sqrt{5}}{2})^{h+2}}{\\sqrt(5)} &lt; 1 \\therefore S(h) &gt; \\frac{(\\frac{1+\\sqrt{5}}{2})^{h+2}}{\\sqrt(5)} - 1$$ AVL树的高度不超过$$\\frac{3}{2}log_2^N$$ 查找时间复杂度: $$O(log_2^N)$$ 插入时间复杂度: $$O(log_2^N)$$+0-2次旋转 删除时间复杂度: $$O(log_2^N)$$+若干次旋转 删除操作最多会造成$$O(log_2^N)$$次旋转，这种情况发生在删除最简AVL树的一个节点时发生。 ###红黑树 红黑树的高度不超过$$2log_2^N$$ 查找时间复杂度: $$O(log_2^N)$$ 插入时间复杂度: $$O(log_2^N)$$+0-2次旋转 删除时间复杂度: $$O(log_2^N)$$+0-3次旋转 所有的AVL树都能不经旋转涂成红黑树，反之不行。 ###红黑树和AVL树对比结论：红黑树和AVL树时间复杂度是一样的，但是红黑树的统计性能更高！ 以下是对它们处理百万随机数的性能统计 ##3. 红黑树的插入和删除 插入我参考的是SGI STL版本的红黑数实现，源码如下： __rb_tree_rebalance(__rb_tree_node_base* x, __rb_tree_node_base*&amp; root) { //参数1为新增节点 x-&gt;color == __rb_tree_red; //新增节点必须为红色 while(x != root &amp;&amp; x-&gt;parent-&gt;color == __rb__tree_red) { if(x-&gt;parent == x-&gt;parent-&gt;parent-&gt;left) { //父节点为组父节点的左节点 __rb_tree_node_base* y = x-&gt;parent-&gt;parent-&gt;right; //令y为伯父节点 if(y &amp;&amp; y-&gt;color == __rb_tree_red) { //情况1 //伯父节点存在并且为红色 x-&gt;parent-&gt;color = __rb_tree_black; y-&gt;color = __rb_tree_black; x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red; x = x-&gt;parent-&gt;parent; //上滤 } else { //无伯父节点，或伯父节点为黑 if(x == x-&gt;parent-&gt;right) { //情况2 x = x-&gt;parent; __rb_tree_rotate_left(x, root); } //情况3 x-&gt;parent-&gt;color = __rb_tree_black; x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red; __rb_tree_rotate_right(x-&gt;parent-&gt;parent, root); } } else { __rb_tree_node_base* y = x-&gt;parent-&gt;parent-&gt;left; //令y为伯父节点 if(y &amp;&amp; y-&gt;color == __rb_tree_red) { //情况4 //伯父节点存在并且为红色 x-&gt;parent-&gt;color = __rb_tree_black; y-&gt;color = __rb_tree_black; y-&gt;parent-&gt;parent-&gt;color = __rb_tree_red; x = x-&gt;parent-&gt;parent; //上滤 } else { //无伯父节点，或伯父节点为黑 if(x == x-&gt;parent-&gt;left) { //情况5 x = x-&gt;parent; __rb_tree_rotate_right(x, root); } //情况6 x-&gt;parent-&gt;color = __rb_tree_black; x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red; __rb_tree_left(x-&gt;parent-&gt;parent, root); } } } root-&gt;color = __rb_tree_black; } ####左旋转动画 ####右旋转动画 ####情况1 直接把父节点和伯父节点改成黑色，祖父节点改成红色，继续上滤就可以了。 ####情况2 把子节点丰富 先对XP做一次左旋转 再对GX做一次右旋转并改变GX的颜色，SGI STL中提前改变了颜色，这是为了代码统一，不影响逻辑。 ####情况3 ####情况4 其实这种情况和情况1是相同的。 ####情况5 做一次左旋转 ####情况6 做一次右左双旋转 升序插入红黑树 降序插入红黑树 随机插入红黑树 ###删除 删除红色节点删除红色节点不影响红黑树的性质，可直接删除！ 删除黑色节点将右子节点的最左端节点代替该节点，然后进行reBlance。如果后继节点为红色，则直接改成黑色，不需要reBlance。经过节点A的所有路径长度都减少了1，reBlance过程中把这些情况分为以下4种。 节点A为删除后的替代节点，节点W为节点A的兄弟节点。 if (y-&gt;color != __rb_tree_red) { while (x != root &amp;&amp; (x == 0 || x-&gt;color == __rb_tree_black)) if (x == x_parent-&gt;left) { __rb_tree_node_base* w = x_parent-&gt;right; //情况1 if (w-&gt;color == __rb_tree_red) { w-&gt;color = __rb_tree_black; x_parent-&gt;color = __rb_tree_red; __rb_tree_rotate_left(x_parent, root); w = x_parent-&gt;right; } //情况2 if ((w-&gt;left == 0 || w-&gt;left-&gt;color == __rb_tree_black) &amp;&amp; (w-&gt;right == 0 || w-&gt;right-&gt;color == __rb_tree_black)) { w-&gt;color = __rb_tree_red; x = x_parent; x_parent = x_parent-&gt;parent; } else { //情况3 if (w-&gt;right == 0 || w-&gt;right-&gt;color == __rb_tree_black) { if (w-&gt;left) w-&gt;left-&gt;color = __rb_tree_black; w-&gt;color = __rb_tree_red; __rb_tree_rotate_right(w, root); w = x_parent-&gt;right; } //情况4 w-&gt;color = x_parent-&gt;color; x_parent-&gt;color = __rb_tree_black; if (w-&gt;right) w-&gt;right-&gt;color = __rb_tree_black; __rb_tree_rotate_left(x_parent, root); break; } } if (x) x-&gt;color = __rb_tree_black; } ####情况1W为红色，AW的父节点为黑色。对BD进行一次左旋，使得情况1转换成情况234中的一种。 ####情况2W和它两个子节点都为黑色把W涂成红色，使得A和W两个子树路径长度都-1。如果new x即B节点为红色，那么涂成黑色，就平衡了B节点的路径长。否则就需要上滤，继续平衡new x和其兄弟节点。 ####情况3W为黑色，W的左节点为红色，右节点为黑色。对WC进行一次右旋，转换为情况4 ####情况4W为黑色，右子节点为红色。对BD进行左旋，并交换颜色，再把W的右节点置为黑色。 查找while(x != 0) if(!key_compare(key(x), k)) //x键值大于k y = x, x = left(x); else x = right(x); iterator j = iterator(y); //k的值比树中最大值都大，或者没有找到，则返回end()。 //例如在root=10 10-&gt;left=8 10-&gt;right=14 14-&gt;left=11中查找12 return (j == end() || key_compare(k, key(j.node())) ? end() : j;","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"blog.codershu.com/tags/数据结构与算法/"}]},{"title":"Alpha分离","date":"2016-10-30T16:00:00.000Z","path":"2016/10/31/separateAlpha/","text":"1. 为什么要进行Alpha分离？ 使得图集可以压缩，减小包量。 2. Alpha分离要点1. 分离 收集图集 123456List&lt;Texture2D&gt; m_AtlasList = new List&lt;Texture2D&gt;();private void CollectAtlasSprite()&#123; //Travel all AtlasSprite m_AtlasList.Add(obj as Texture2D);&#125; 分离单张图集的Alpha 123456789101112131415161718192021222324252627282930public static void separateOneTexture(Texture2D sourceTex)&#123; string sourceTexPath= AssetDatabase.GetAssetPath(sourceTex); //创建2张RGB格式的纹理，最后保存的时候会把rgba的alpha丢弃掉。 Texture2D texRGB = new Texture2D(sourceTex.width, sourceTex.height, TextureFormat.RGB24, false); Texture2D texAlpha = new Texture2D(sourceTex.width, sourceTex.height, TextureFormat.RGB24, false); //取得原始像素数据 Color[] srcColors = sourceTex.GetPixels(); texRGB.SetPixels(srcColors); //生成 rgba = (a, a, a, a) 的图片 Color[] alphaColors = new Color[srcColors.Length]; for(int i=0;i&lt;srcColors.Length;i++) &#123; alphaColors[i].r = srcColors[i].a; alphaColors[i].g = srcColors[i].a; alphaColors[i].b = srcColors[i].a; &#125; texAlpha.SetPixels(alphaColors); texRGB.Apply(); texAlpha.Apply(); byte[] rgbBytes = texRGB.EncodeToPNG(); File.WriteAllBytes(sourceTexPath, rgbBytes); byte[] alphaBytes = texAlpha.EncodeToPNG(); File.WriteAllBytes(alphaTexPath, alphaBytes);&#125; 记得检查图片的AssetImporter.GetAtPath(sourceTexFullPath).isReadable == true，否则不能进行SetPixels和GetPixels操作 2. 合并 合并Alpha图片和RGB图片 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void mergeTwoTexture(Texture2D t2dRGB,Texture2D t2dAlpha)&#123; string strRGBPath = AssetDatabase.GetAssetPath(t2dRGB); string strAlphaPath = AssetDatabase.GetAssetPath(t2dAlpha); TextureImporter importerRGBTex = AssetImporter.GetAtPath(strRGBPath) as TextureImporter; if (!importerRGBTex.isReadable) &#123; //检查isReadable属性 importerRGBTex.isReadable = true; AssetDatabase.ImportAsset(strRGBPath); &#125; TextureImporter importerAlphaTex = AssetImporter.GetAtPath(strAlphaPath) as TextureImporter; if(!importerAlphaTex.isReadable) &#123; //检查isReadable属性 importerAlphaTex.isReadable = true; AssetDatabase.ImportAsset(strAlphaPath); &#125; Color[] rgbDatas = t2dRGB.GetPixels(); Color[] alphaDatas = t2dAlpha.GetPixels(); Color[] rgbaDatas = new Color[rgbDatas.Length]; Texture2D texRGBA = new Texture2D(t2dRGB.width, t2dRGB.height, TextureFormat.RGBA32,false); for(int nI=0;nI&lt;rgbaDatas.Length;nI++) &#123; rgbaDatas[nI].r = rgbDatas[nI].r; rgbaDatas[nI].g = rgbDatas[nI].g; rgbaDatas[nI].b = rgbDatas[nI].b; rgbaDatas[nI].a = alphaDatas[nI].r; &#125; texRGBA.SetPixels(rgbaDatas); texRGBA.Apply(); byte[] rgbaBytes = texRGBA.EncodeToPNG(); File.WriteAllBytes(strRGBPath, rgbaBytes); AssetDatabase.DeleteAsset(strAlphaPath); AssetDatabase.Refresh(); ReImportAsset(strRGBPath); &#125;","tags":[{"name":"Unity","slug":"Unity","permalink":"blog.codershu.com/tags/Unity/"}]},{"title":"Xcode8自动打包去掉AutoMaticallyManageSigning","date":"2016-10-30T16:00:00.000Z","path":"2016/10/31/xcode8automaticallymanag/","text":"最近项目里的自动打包脚本不能用了，一直提示123456789Check dependenciesSigning for \"Unity-iPhone\" requires a development team. Select a development team in the project editor.Code signing is required for product type 'Application' in SDK 'iOS 10.0'** BUILD FAILED **The following build commands failed: Check dependencies(1 failure) Google了一下发现是xcode新的自动管理签名机制的问题，你要不使用AutoMatic自动管理，要不使用Manual手动指定证书的模式。 无奈我们打包的时候只有证书，没有对应的AppleID，所以自动管理的就用不了。但是UnityBuild出来的Xcode项目是自动勾选Auto MaticallyManageSigning的，而且Xcode也没有支持用命令行设置这个值。那这样的话，我们每次打包出Xcode项目的时候需要手动点一下，这就失去打包工具的意义了。 无奈之下，找到一个办法解决这个问题。我先用UnityBuild出一个干净的Xcode项目，然后把项目传到Git。然后手动点一下BuildSetting里的Auto MaticallyManageSigning，去掉勾选。然后查看下diff，当然其中有很多修改。主要修改在Unity-iPhone.xcodeproj\\/project.pbxproj，在Finder里想打开该文件应选中Unity-iPhone.xcodeproj右键显示包内容。 project.pbxproj内也有很多修改，重要的修改其实只有几行，主要是在这个地方加上ProvisioningStyle = Manual。 修改前： 12345TargetAttributes = &#123; 5623C57217FDCB0800090B9E /* Unity-iPhone Tests */ = &#123; TestTargetID = 1D6058900D05DD3D006BFB54 /* Unity-iPhone */; &#125;;&#125;; 修改后： 12345678TargetAttributes = &#123; 5623C57217FDCB0800090B9E /* Unity-iPhone Tests */ = &#123; TestTargetID = 1D6058900D05DD3D006BFB54 /* Unity-iPhone */; &#125;; 1D6058900D05DD3D006BFB54 = &#123; ProvisioningStyle = Manual; &#125;;&#125;; 需要注意的是从来没有用Xcode打开并且操作过的project.pbxproj是不存在ProvisioningStyle字段的，所以应追加3行。但是打开并操作过的项目是存在ProvisioningStyle字段的，这个时候如果想用脚本修改该值应直接替换该值1sed -i \"\" s/'ProvisioningStyle = Automatic;'/'DevelopmentTeam = None;ProvisioningStyle = Manual;'/g project.pbxprojPath 因为我们是全自动的打包过程，正常流程是不用打开xcode项目的，所以我准备用sed在指定文本下追加3行，并且要获取上一次匹配到的TestTargetID，我写到3点还没写出来……实在不会。所以我用python实现了这个操作，附上python脚本DelMatically.py。1234567891011121314#!/usr/bin/pythonimport osimport reprint 'start python script! Delete AutoMatically Manage Signing'filePath = \"/Users/yons/Documents/work/bin/prj/Unity-iPhone.xcodeproj/project.pbxproj\"f = open(filePath, 'r+')contents = f.read()f.seek(0)f.truncate()pattern = re.compile(r'(TestTargetID = (\\w*)) \\/\\* Unity-iPhone \\*\\/;')f.write(pattern.sub(r'\\1;\\n\\t\\t\\t\\t\\t&#125;;\\n\\t\\t\\t\\t\\t\\2 = &#123;\\n\\t\\t\\t\\t\\t\\tProvisioningStyle = Manual;', contents))f.close()print 'end python script !' 然后用shell运行python，把xcodeprojPath和Yours换成你们自己对应的值。12python DelAutoMatically.pyxcodebuild -project xcodeprojPath -sdk iphoneos -scheme \"Unity-iPhone\" CONFIGURATION_BUILD_DIR='./' CODE_SIGN_IDENTITY=\"Yours\" PROVISIONING_PROFILE=\"Yours\" 需要注意的是PROVISIONING_PROFILE值应该是一串数字+字母，这个值可以用NodePad++打开对应的mobileprovision文件，其中有如下结构。其中string标签包裹的值即是PROVISIONING_PROFILE。 12&lt;key&gt;UUID&lt;/key&gt;&lt;string&gt;&lt;/string&gt;","tags":[{"name":"Xcode打包","slug":"Xcode打包","permalink":"blog.codershu.com/tags/Xcode打包/"}]}]
[{"title":"实时阴影","date":"2016-12-15T02:42:00.000Z","path":"2016/12/15/shadow/","text":"1. Unity内部的ShadowCasterShaderPass { Name &quot;ShadowCaster&quot; Tags { &quot;LightMode&quot;=&quot;ShadowCaster&quot; } CGPROGRAM #pragma vertex vert #pragma fragment frag #pragma multi_compile_shadowcaster #include &quot;UnityCG.cginc&quot; struct v2f { V2F_SHADOW_CASTER; }; v2f vert(appdata_base v) { v2f o; TRANSFER_SHADOW_CASTER_NORMALOFFSET(o) return o; } float4 frag(v2f i) : SV_Target { SHADOW_CASTER_FRAGMENT(i) } ENDCG } 2. ShadowRecv 在ForwardRendering.shader中添加SHADOW_COORDS TRANSFER_SHADOW SHADOW_ATTENUATION即可变成ShadowRecv.shader Shader &quot;UnityShaderLearning/ShadowRecv&quot; { Properties { _Diffuse(&quot;Diffuse&quot;, Color) = (1, 1, 1, 1) _Specular(&quot;Specular&quot;, Color) = (1, 1, 1, 1) _Gloss(&quot;Gloss&quot;, Range(8.0, 256)) = 20 } SubShader { Pass { Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; } CGPROGRAM #pragma multi_compile_fwbase #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; #include &quot;AutoLight.cginc&quot; fixed4 _Diffuse; fixed4 _Specular; float _Gloss; struct a2v { float4 vertex : POSITION; float3 normal : NORMAL; }; struct v2f { float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; SHADOW_COORDS(2) }; v2f vert(a2v v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.worldNormal = normalize(mul(v.normal, (float3x3)_World2Object)); o.worldPos = mul(_Object2World, v.vertex).xyz; TRANSFER_SHADOW(o); return o; } fixed4 frag(v2f i) :SV_Target { fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir)); fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz); fixed3 halfDir = normalize(viewDir + worldLightDir); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(worldNormal, halfDir)), _Gloss); fixed atten = 1.0; fixed4 shadow = SHADOW_ATTENUATION(i); return fixed4(ambient + (diffuse + specular) * atten * shadow, 1.0); } ENDCG } Pass { Tags { &quot;LightMode&quot;=&quot;ForwardAdd&quot; } Blend SrcAlpha One CGPROGRAM #pragma multi_compile_fwbase #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; #include &quot;AutoLight.cginc&quot; fixed4 _Diffuse; fixed4 _Specular; float _Gloss; struct a2v { float4 vertex : POSITION; float3 normal : NORMAL; }; struct v2f { float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; }; v2f vert(a2v v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(_Object2World, v.vertex).xyz; return o; } fixed4 frag(v2f i) : SV_Target { fixed3 worldNormal = normalize(i.worldNormal); #ifdef USING_DIRECTIONAL_LIGHT fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); #else fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz - i.worldPos.xyz); #endif fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(0, dot(worldNormal, worldLightDir)); fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz); fixed3 halfDir = normalize(worldLightDir + viewDir); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss); #ifdef USING_DIRECTIONAL_LIGHT fixed atten = 1.0; #else #if defined (POINT) float3 lightCoord = mul(_LightMatrix0, float4(i.worldPos, 1)).xyz; fixed atten = tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL; #elif defined (SPOT) float4 lightCoord = mul(_LightMatrix0, float4(i.worldPos, 1)); fixed atten = (lightCoord.z &gt; 0) * tex2D(_LightTexture0, lightCoord.xy / lightCoord.w + 0.5).w * tex2D(_LightTextureB0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL; #else fixed atten = 1.0; #endif #endif return fixed4((diffuse + specular) * atten, 1.0); } ENDCG } } FallBack &quot;Specular&quot; } 3. 透明物体的阴影效果 Shader &quot;UnityShaderLearning/AlphaTestWithShadow&quot; { Properties { _Color (&quot;Main Tint&quot;, Color) = (1, 1, 1, 1) _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot;{} _Cutoff (&quot;Alpha Cutoff&quot;, Range(0, 1)) = 0.55 } SubShader { Tags { &quot;Queue&quot;=&quot;AlphaTest&quot; &quot;IgnoreProjector&quot; = &quot;True&quot; &quot;RenderType&quot;=&quot;TransparentCutout&quot;} Pass { Tags { &quot;LightMode&quot;=&quot;ForwardBase&quot; } Cull Off CGPROGRAM #pragma multi_compile_fwdbase #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; #include &quot;AutoLight.cginc&quot; fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; fixed _Cutoff; struct a2v { float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; float2 uv : TEXCOORD2; SHADOW_COORDS(3) }; v2f vert(a2v v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(_Object2World, v.vertex).xyz; o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); TRANSFER_SHADOW(o); return o; } fixed4 frag(v2f i) : SV_Target { fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); fixed4 texColor = tex2D(_MainTex, i.uv); clip (texColor.a - _Cutoff); fixed3 albedo = texColor.rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir)); UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos); return fixed4(ambient + diffuse * atten, 1.0); } ENDCG } } FallBack &quot;VertexLit&quot; }","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"遮罩纹理","date":"2016-12-07T15:55:00.000Z","path":"2016/12/07/masktexture/","text":"左图使用了遮罩纹理，右侧是普通的Blin-Phone模型，在高光上表现得更加细腻。 上图是使用了主纹理/法线贴图/遮罩纹理的效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283Shader &quot;UnityShaderLearning/MaskTexture&quot; &#123; Properties &#123; _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1) _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot;&#123;&#125; _BumpMap (&quot;Nomral Map&quot;, 2D) = &quot;bump&quot;&#123;&#125; _BumpScale(&quot;Bump Scale&quot;, Float) = 1.0 _SpecularMask (&quot;Specular Mask&quot;, 2D) = &quot;white&quot;&#123;&#125; _SpecularScale (&quot;Specular Scale&quot;, Float) = 1.0 _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1) _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20 &#125; SubShader &#123; Pass &#123; Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; sampler2D _BumpMap; float _BumpScale; sampler2D _SpecularMask; float _SpecularScale; fixed4 _Specular; float _Gloss; struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; float4 texcoord : TEXCOORD0; &#125;; struct v2f &#123; float4 pos : SV_POSITION; float2 uv : TEXCOORD0; float3 lightDir : TEXCOORD1; float3 viewDir : TEXCOORD2; &#125;; v2f vert(a2v v) &#123; v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.uv.xy = v.texcoord.xy * _MainTex_ST.xy * _MainTex_ST.zw; TANGENT_SPACE_ROTATION; o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz; o.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz; return o; &#125; fixed4 frag(v2f i) : SV_Target &#123; fixed3 tangentLightDir = normalize(i.lightDir); fixed3 tangentViewDir = normalize(i.viewDir); fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uv)); tangentNormal.xy *= _BumpScale; tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy))); fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(tangentNormal, tangentLightDir)); fixed3 halfDir = normalize(tangentLightDir + tangentViewDir); fixed specularMask = tex2D(_SpecularMask, i.uv).r * _SpecularScale; fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(tangentNormal, halfDir)), _Gloss) * specularMask; return fixed4(ambient + diffuse + specular, 1.0); &#125; ENDCG &#125; &#125; FallBack &quot;Diffuse&quot;&#125;","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"渐变纹理","date":"2016-12-06T17:07:00.000Z","path":"2016/12/07/ramptexture/","text":"12fixed halfLambert = 0.5 * dot(worldNormal, worldLightDir) + 0.5;fixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert, halfLambert)).rgb * _Color.rgb; 关键代码有两行 第一行代码获得了法线和光线方向的夹角的余弦值*0.5 + 0.5, 即把余弦值映射到[0, 1]。 第二行代码在渐变纹理上采样 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Shader &quot;UnityShaderLearning/RampTexture&quot; &#123; Properties &#123; _Color (&quot;Color Tint&quot;, Color) = (1,1,1,1) _RampTex (&quot;Ramp Tex&quot;, 2D) = &quot;white&quot; &#123;&#125; _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1) _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20 &#125; SubShader &#123; Pass &#123; Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; fixed4 _Color; sampler2D _RampTex; float4 _RampTex_ST; fixed4 _Specular; float _Gloss; struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord : TEXCOORD0; &#125;; struct v2f &#123; float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; float2 uv : TEXCOORD2; &#125;; v2f vert(a2v v) &#123; v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(_Object2World, v.vertex).xyz; o.uv = TRANSFORM_TEX(v.texcoord, _RampTex); return o; &#125; fixed4 frag(v2f i) : SV_Target &#123; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed halfLambert = 0.5 * dot(worldNormal, worldLightDir) + 0.5; fixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert, halfLambert)).rgb * _Color.rgb; fixed3 diffuse = _LightColor0.rgb * diffuseColor; fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos)); fixed3 halfDir = normalize(worldLightDir + viewDir); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss); return fixed4(ambient + diffuse + specular, 1.0); &#125; ENDCG &#125; &#125; FallBack &quot;Diffuse&quot;&#125;","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"切线空间下的法线贴图应用","date":"2016-12-06T16:26:00.000Z","path":"2016/12/07/normalmaptangentspace/","text":"左侧BumpScale为-1 右侧BumpScale为1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889Shader &quot;UnityShaderLearning/NormalMapTangentSpace&quot;&#123; Properties &#123; _Color(&quot;Color Tint&quot;, Color) = (1, 1, 1, 1) _MainTex(&quot;Main Tex&quot;, 2D) = &quot;white&quot;&#123;&#125; _BumpMap(&quot;Normal Map&quot;, 2D) = &quot;bump&quot;&#123;&#125; _BumpScale(&quot;Bump Scale&quot;, Float) = 1.0 _Specular(&quot;Specular&quot;, Color) = (1, 1, 1, 1) _Gloss(&quot;Gloss&quot;, Range(8.0, 256)) = 20 &#125; SubShader &#123; Pass &#123; Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; sampler2D _BumpMap; float4 _BumpMap_ST; float _BumpScale; fixed4 _Specular; float _Gloss; struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; float4 texcoord : TEXCOORD0; &#125;; struct v2f &#123; float4 pos : SV_POSITION; float4 uv : TEXCOORD0; float3 LightDir : TEXCOORD1; float3 ViewDir : TEXCOORD2; &#125;; v2f vert(a2v v) &#123; v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.uv.xy = v.vertex.xy * _MainTex_ST.xy + _MainTex_ST.zw; o.uv.zw = v.vertex.xy * _BumpMap_ST.xy + _BumpMap_ST.zw; float3 binormal = cross(normalize(v.normal), normalize(v.tangent.xyz)); float3x3 rotation = float3x3(v.tangent.xyz, binormal, v.normal); o.LightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz; o.ViewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz; return o; &#125; fixed4 frag(v2f i) : SV_Target &#123; fixed3 tangentLightDir = normalize(i.LightDir); fixed3 tangentViewDir = normalize(i.ViewDir); fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw); fixed3 tangentNormal; // tangentNormal.xy = (packedNormal.xy * 2 - 1) * _BumpScale; // tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy))); tangentNormal = UnpackNormal(packedNormal); tangentNormal.xy *= _BumpScale; tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy))); fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT * albedo; fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(tangentNormal, tangentLightDir)); fixed3 halfDir = normalize(tangentViewDir + tangentLightDir); fixed3 specular = _LightColor0 * _Specular.rgb * pow(max(0, dot(tangentNormal, halfDir)), _Gloss); return fixed4(ambient + diffuse + specular, 1.0); &#125; ENDCG &#125; &#125; FallBack &quot;specular&quot;&#125;","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"逐顶点和逐像素的高光模型","date":"2016-11-18T17:26:00.000Z","path":"2016/11/19/specularvertexlevelpixellevel/","text":"左为逐顶点高光Phong模型 中为逐像素高光Phong模型 右为逐像素高光Blinn-Phong模型 Phong模型$$C{specular=(c{light}*m{specular})max(0, \\vec{v}·\\vec{r})^{m{Gloss}}}$$ Blinn-Phong模型$$C{specular=(c{light}*m{specular})max(0, \\vec{n}·\\vec{h})^{m{Gloss}}}$$ $$\\vec{h} = \\frac{\\vec{v}·\\vec{i}}{|v||i|}$$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Shader &quot;UnityShaderLearning/SpecularVertexLevel&quot;&#123; Properties &#123; _Diffuse(&quot;Diffuse&quot;, Color) = (1, 1, 1, 1) _Specular(&quot;Specular&quot;, Color) = (1, 1, 1, 1) _Gloss(&quot;Gloss&quot;, Range(8.0, 256)) = 20 &#125; SubShader &#123; Pass &#123; Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; fixed4 _Diffuse; fixed4 _Specular; float _Gloss; struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; &#125;; struct v2f &#123; float4 pos : SV_POSITION; float3 color : COLOR; &#125;; v2f vert(a2v v) &#123; v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 worldNormal = normalize(mul(v.normal, (float3x3)_World2Object)); fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir)); fixed3 reflectDir = normalize(reflect(-worldLightDir, worldNormal)); fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - mul(_Object2World, v.vertex).xyz); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(reflectDir, viewDir)), _Gloss); o.color = ambient + diffuse + specular; return o; &#125; fixed4 frag(v2f i) :SV_Target &#123; return fixed4(i.color, 1.0); &#125; ENDCG &#125; &#125; FallBack &quot;Specular&quot;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Shader &quot;UnityShaderLearning/SpecularPixelLevel&quot;&#123; Properties &#123; _Diffuse(&quot;Diffuse&quot;, Color) = (1, 1, 1, 1) _Specular(&quot;Specular&quot;, Color) = (1, 1, 1, 1) _Gloss(&quot;Gloss&quot;, Range(8.0, 256)) = 20 &#125; SubShader &#123; Pass &#123; Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; fixed4 _Diffuse; fixed4 _Specular; float _Gloss; struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; &#125;; struct v2f &#123; float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; &#125;; v2f vert(a2v v) &#123; v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.worldNormal = normalize(mul(v.normal, (float3x3)_World2Object)); o.worldPos = mul(_Object2World, v.vertex).xyz; return o; &#125; fixed4 frag(v2f i) :SV_Target &#123; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir)); fixed3 reflectDir = normalize(reflect(-worldLightDir, worldNormal)); fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(reflectDir, viewDir)), _Gloss); fixed3 color = ambient + diffuse + specular; return fixed4(color, 1.0); &#125; ENDCG &#125; &#125; FallBack &quot;Specular&quot;&#125;``` ``` fixed3 halfDir = normalize(viewDir + worldLightDir);fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(worldNormal, halfDir)), _Gloss);","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]},{"title":"DiffuseVertexLevel/PixelLevel(漫反射)","date":"2016-11-17T16:24:00.000Z","path":"2016/11/18/diffuseshadervertexlevel/","text":"左为逐顶点漫反射光照模型，右为逐像素漫反射光照模型。 漫反射光照模型 $$C{diffuse}=(C{light} * m_{diffuse})max(0, \\vec{n}·\\vec{i})$$ $$C_{light}$$入射光颜色和强度 $$m_{diffuse}$$材质漫反射系数 $$\\vec{n}$$法线方向 $$\\vec{i}$$光源方向 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Shader &quot;UnityShaderLearning/DiffuseVertexLevel&quot;&#123; Properties &#123; _Diffuse(&quot;Diffuse&quot;, Color) = (1, 1, 1, 1) &#125; SubShader &#123; Pass &#123; Tags&#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; fixed4 _Diffuse; struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; &#125;; struct v2f &#123; float4 pos : SV_POSITION; fixed3 color : COLOR; &#125;; v2f vert(a2v v) &#123; v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 worldNormal = normalize(mul(v.normal, (float3x3)_World2Object)); fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz); fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLight)); o.color = ambient + diffuse; return o; &#125; fixed4 frag(v2f i) : SV_Target &#123; return fixed4(i.color, 1.0); &#125; ENDCG &#125; &#125; FallBack &quot;Diffuse&quot;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Shader &quot;UnityShaderLearning/DiffusePixelLevel&quot;&#123; Properties &#123; _Diffuse(&quot;Diffuse&quot;, Color) = (1, 1, 1, 1) &#125; SubShader &#123; Pass &#123; Tags&#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; fixed4 _Diffuse; struct a2v &#123; float4 vertex : POSITION; float3 normal : NORMAL; &#125;; struct v2f &#123; float4 pos : SV_POSITION; fixed3 worldNormal : TEXCOORD0; &#125;; v2f vert(a2v v) &#123; v2f o; o.pos = mul(UNITY_MATRIX_MVP, v.vertex); o.worldNormal =mul(v.normal, (float3x3)_World2Object); return o; &#125; fixed4 frag(v2f i) : SV_Target &#123; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir)); fixed3 color = ambient + diffuse; return fixed4(color, 1.0); &#125; ENDCG &#125; &#125; FallBack &quot;Diffuse&quot;&#125;","tags":[{"name":"UnityShader","slug":"UnityShader","permalink":"blog.codershu.com/tags/UnityShader/"}]}]